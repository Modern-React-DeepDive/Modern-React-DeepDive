# **2장 리액트 핵심 요소 깊게 살펴보기**

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
'무조건 메모이제이션은 필요하다' vs '메모이제이션을 섣불리 해서는 안 된다'
### 2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자.

대부분의 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

메모이제이션은 모든 것을 해결할 수 있는 마법과 같은 것이 아닌 비용이 드는 것이다.<br><span style="background-color:#fff5b1">값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업</span>, 그리고 <span style="background-color:#fff5b1">이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다</span>는 두 가지 비용이 있다.

이 비용이 리렌더링 비용보다 저렴한지는 <span style="background-color:#fff5b1">상황에 따라 다르다.</span>


❗️미리 개발자가 렌더링이 많이 될 것 같은 부분을 예측해 메모이제이션하는, 섣부른 최적화는 옳지 못한 행동이다. 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 **실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것**이 옳다.

### 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

메모이제이션을 위해서는 cpu와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다. 그런데 이 작업은 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 하는 `기본적인 리액트의 재조정 알고리즘`이다.

즉, 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다.<br>따라서 <span style="background-color:#fff5b1">우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것</span>이다.
물론 이 비용 또한 무시할 수 없다. props가 크고 복잡해진다면 이 비용 또한 커질 수 있다.

반면 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.
- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

❗️정리하자면, 메모이제이션은 하지 않는 것보다 메모이제이션을 했을 때 더 많은 이점을 누릴 수 있다. 이것이 비록 섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점, 그리고 이를 **실수로 빠뜨렸을 때 치러야 할 위험 비용이 크기 때문에** 최적화에 대한 확신이 없다면 `가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.`

✅ 참조의 투명성 : 함수가 동일한 입력에 대해 항상 동일한 출력을 반환하는 것을 의미한다.