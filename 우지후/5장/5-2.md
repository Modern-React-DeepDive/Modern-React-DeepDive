# **5장 리액트와 상태관리 라이브러리**

## 5.2 리액트 훅으로 시작하는 상태 관리

현재는 새로운 Context API, useReducer, useState의 등장으로 컴포넌트에 걸쳐서 재사용하거나 혹은 컴포넌트 내부에 걸쳐서 상태를 관리할 수 있는 방법들이 점차 등장하기 시작했고, 덕분에 리덕스 외의 다른 상태 관리 라이브러리를 선택하는 경우도 많아지고 있다. 
### 5.2.1 가장 기본적인 방법: useState와 useReducer

useState의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됐다.

```javascript
function useCounter(initCount: number = 0) {
const [counter, setCounter] = useState(initCount)
function inc() {
setCounter ((prev) => prev + 1)
}
return { counter, inc }
}
```

이 예제는 useCounter라는 훅을 만들어서 함수 컴포넌트 어디에서든 사용할 수 있게 구현한 사례다.

다음 코드와 같이 useCounter를 사용하는 함수 컴포넌트는 이 훅을 사용해 각자의 counter 변수를 관리하며, 중복되는 로직 없이 숫자를 1씩 증가시키는 기능을 손쉽게 이용할 수 있다.

```javascript
function useCounter (initCount: number = 0) {
const [counter, setCounter] = useState(initCount)

function inc() {
setCounter ((prev) = prev + 1)
}
return { counter, inc }
}

function Counter1() {
const { counter, inc } = useCounter()
return (
    <>
        <h3>Counter1: {counter}</h3>
        <button onClick={inc}>+</button>
    </>
)
}

function Counter2() {
const { counter, inc } = useCounter ()
return (
<>
<h3>Counter2: {counter}</h3>
<button onClick={inc}>+</button>
</>
)
}
```

useCounter라는 훅이 없었다면 이러한 기능이 필요한 각각의 컴포넌트에서 모두 위와 같은 내용을 구현해야만 했을 것이다. 더 나아가 훅 내부에서 관리해야 하는 상태가 복잡하거나 상태를 변경할 수 있는 시나리오가 다양해진다면 훅으로 코드를 격리해 제공할 수 있다는 장점이 더욱 크게 드러날 것이다.

이처럼 리액트 훅을 기반으로 만든 사용자 정의 훅은 함수 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점이 있다.

useState나 useReducer 모두 약간의 구현상의 차이만 있을 뿐, 두 훅 모두 지역 상태 관리를 위해 만들어졌다는 것을 알 수 있다.

그러나 useState와 useReducer가 상태 관리의 모든 필요성과 문제를 해결해 주지는 않는다. useState와 useReducer를 기반으로 하는 사용자 지정 훅의 한계는 명확하다. 훅을 사용할 때마다 컴포넌트 별로 초기화 되므로 <span style="background-color:#fff5b1">컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.</span> 결론적으로 컴포넌트별로 상태의 파편화를 만들어버린다. 이렇게 기본적인 useState를 기반으로 한 상태를 지역 상태(local state)라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

만약 useCounterd에서 제공하는 counter를 올리는 함수는 지금처럼 동일하게 사용하되, 두 컴포넌트가 동일한 counter 상태를 바라보게 하기 위해서는 어떻게 해야 할까? 즉, 현재 지역 상태인 counter를 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태(global state)로 만들어 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면 어떻게 해야 할까? 가장 먼저 떠오르는 방법은 상태를 컴포넌트 밖으로 한 단계 끌어올리는 것이다.

Parent라고 불리는 상위 컴포넌트에서만 useCounter를 사용하고, 이 훅의 반환값을 하위 컴포넌트의 props로 제공했다. 즉, 지역 상태인 useCounter를 부모 컴포넌트로 한 단계 끌어올린 다음, 이 값을 하위 컴포넌트에서 참조해 재사용하게끔 만들었다.

여러 컴포넌트가 동일한 상태를 사용할 수 있게 됐다는 점은 주목할 만하지만 Props 형태로 필요한 컴포넌트에 제공해야 한다는 점은 여전히 조금은 불편해 보인다.

이 두 훅은 만들기에 따라 재사용할 수 있는 지역 상태를 만들어 주지만 이는 지역 상태라는 한계 때문에 <span style="background-color:#fff5b1">여러 컴포넌트에 걸쳐 공유하기 위해서는 컴포넌트 트리를 재설계하는 등의 수고로움이 필요하다.</span>


### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

만약 useState가 리액트 클로저가 아닌 다른 자바스크립트 실행 문맥 어디에선가, 즉 완전히 다른 곳에서 초기화돼서 관리되면 어떨까? 그리고 그 상태를 참조하는 유효한 스코프 내부에서는 해당 객체의 값을 공유해서 사용할 수도 있지 않을까?

아쉽게도 이 방식은 리액트 환경에서 작동되지 않는다. 컴포넌트가 리렌더링되지 않는다. 원인은 바로 리액트의 렌더링 방식 때문이다. 새로운 상태를 사용자의 UI에 보여주기 위해서는 반드시 리렌더링이 필요하다.

즉, 업데이트되는 값을 가져오려면 상태를 업데이트하는 것뿐만 아니라 상태가 업데이트됐을 때 이를 컴포넌트에 반영시키기 위한 리렌더링이 필요하다.

컴포넌트에서 리렌더링을 하려면 다음과 같은 작업 중 하나가 일어나야 한다.
- useState, useReducer의 반환값 중 두 번째 인수가 어떻게든 호출된다. 
- 부모 함수(부모 컴포넌트)가 리렌더링되거나 해당 함수(함수 컴포넌트)가 다시 실행돼야 한다.

### 5.2.3 useState와 Context를 동시에 사용해 보기

useStore 내지는 useStoreSelector 훅을 활용해 useState로 관리하지 않는 외부 상태값을 읽어오고 리렌더링까지 일으켜서 마치 상태 관리 라이브러리처럼 사용하는 예제를 만들었다. 그러나 이 두가지 훅에도 한 가지 단점이 있다. 이 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다는 것이다. 하나의 스토어를 가지면 이 스토어는 마치 전역 변수처럼 작동하게 되어 동일한 형태의 여러 개의 스토어를 가질 수 없게 된다. 

만약 훅을 사용하는 서로 다른 스코프에서 스토의 구조는 동일하되, 여러 개의 서로 다른 데이터를 공유해 사용하고 싶다면 어떻게 해야 할까?

가장 먼저 떠오르는 방법은 createStore를 이용해 동일한 타입으로 스토어를 여러 개 만드는 것이다.
그러나 이 방법은 완벽하지도 않고 매우 번거롭다. 먼저 해당 스토어가 필요할 때마다 반복적으로 스토어를 생성해야 한다. 또한 훅은 스토어에 의존적인 1:1 관계를 맺고 있으므로 스토어를 만들 때마다 해당 스토어에 의존적인 useStore와 같은 훅을 동일한 개수로 생성해야 한다. 마지막으로 이러한 수고로움을 견디고 훅을 하나씩 만들었다고 하더라도 이 훅이 어느 스토어에서 사용 가능한지를 가늠하려면 오직 훅의 이름이나 스토어의 이름에 의지해야 한다는 어려움이 있다.

이 문제를 해결하는 좋은 방법은 바로 리액트의 `Context`이다. Context를 활용해 해당 스토어를 하위 컴포넌트에 주입한다면 컴포넌트에서는 자신이 주입된 스토어에 대해서만 접근할 수 있게 될 것이다.

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

이번에는 리액트 생테계에서 많은 개발자들이 사용하고 있는 상태 관리 라이브러리에 대해 알아보고자 한다.

Recoil과 Jotai는 Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데 초점을 맞추고 있다. 그리고 Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리다.

Recoil, Jotai와는 다르게 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식이다.