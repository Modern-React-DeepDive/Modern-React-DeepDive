# **1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트**

## 1.5 이벤트 루프와 비동기 통신의 이해
자바스크립트는 싱글 스레드에서 작동한다. 즉, <span style="background-color:#fff5b1">기본적으로 자바스크립트는 한 번에 하나의 작업만 동기 방식으로만 처리</span>할 수 있다.

<span style="color:gray">* 동기(synchronous) : 직렬 방식으로 작업을 처리하는 것, 이 요청이 시작된 후에는 무조건 응답을 받은 이후에야 다른 작업 처리 가능.</span>

그러나 이러한 싱글 스레드 기반의 자바스크립트에서도 많은 양의 비동기 작업이 이루어지고 있다. 어떻게 이러한 것이 가능한지 알기 위해서는 <span style="background-color:#fff5b1">이러한 비동기 작업이 어떻게 처리되는지 이해</span>하고 비동기 처리를 도와주는 `이벤트 루프`를 비롯한 다양한 개념에 대해 알고 있어야 한다.<br>

### 1.5.1 싱글 스레드 자바스크립트

과거에는 프로그램을 실행하는 단위가 <span style="background-color:#fff5b1">오직 프로세스뿐</span>이었다.<br>
하나의 프로그램에서 동시에 여러 개의 복잡한 작업을 수행하기 어려웠는데, 그래서 탄생한 더 작은 실행 단위가 바로 `스레드(thread)`이다.

❓ 왜 자바스크립트는 싱글스레드로 설계됐을까
> `내부적으로 처리가 복잡`하고 동시에 여러작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 `동시성 문제`가 발생할 수 있다. 또한 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제가 일어날 수 있다.

<br>

`Run-to-completion`<br>
> 자바스크립트의 특징 중 하나로, 하나의 작업이 끝나기 전까지는 다른 작업이 실행되지 않는다는 것을 말한다.
<br>
<br>
### 1.5.2 이벤트 루프란?
이벤트 루프는 자바스크립트 표준에 나와 있는 내용은 아니다. 즉, `이벤트 루프`란 자바스크립트 런타임 <span style="background-color:#fff5b1">외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치</span>라고 볼 수 있다.<br><br><br>
`호출 스택과 이벤트 루프`<br>
호출 스택(call stack)은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.<br><br>
다음 예제로 확인해보자.<br>
```javascript
function bar() {
  console.log("bar")
}

function baz() {
  console.log("baz")
}

function foo() {
  console.log("foo")
  bar()
  baz()
}

foo()
```

이 코드들은 대략 다음과 같은 순서로 호출 스택에 쌓이고 비워지게 된다.
> 1. foo()가 호출 스택에 먼저 들어간다.
> 2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
> 3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다.(아직 foo()는 존재)
> 4. bar()가 호출 스택에 들어간다.
> 5. bar() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
> 6. 5의 실행이 완료된 이후에 다음 코드로 넘어간다.(아직 foo(), bar()는 존재)
> 7. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo() 존재)
> 8. baz()가 호출 스택에 들어간다.
> 9. baz()내부에 console.log가 있으므로 호출 스택에 들어간다.
> 10. 9의 실행이 완료된 이후 다음 코드로 넘어간다. (아직 foo(), baz()는 존재)
> 11. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다 (아직 foo()는 존재)
> 12. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
> 13. 이제 호출 스택이 완전히 비워졌다.
<br>

이 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 `이벤트 루프`이다.<br>
이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. <br>
한 가지 알아둘 점은 **코드를 실행하는 것**과 **호출 스택이 비어있는지 확인하는 것**은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어난다는 것이다.<br>
<br>
그렇다면 비동기 작업은 어떻게 실행될까?
```javascript
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 0);
  baz();
}

foo();
```
실제로 호출 스택 내부에서는 다음과 같은 일이 발생한다.<br>

> 1. foo()가 호출 스택에 먼저 들어간다.
> 2. foo()내부에 console.log가 있으므로 호출 스택에 들어간다.
> 3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다(foo는 아직 존재)
> 4. setTimeout(bar(), 0)이 호출 스택에 들어간다.
> 5. 4번에 대해 타이머 이벤트가 실행되며 <span style="background-color:#fff5b1">태스크 큐</span>로 들어가고, <span style="background-color:#fff5b1">그 대신 바로 스택에서 제거된다.</span>
> 6. baz()가 호출 스택에 들어간다.
> 7. baz()내부에 console.log가 있으므로 호출 스택에 들어간다.
> 8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다(아직 foo, baz는 존재)
> 9. 더 이상 baz에 남은 것이 없으므로 호출 스택에서 제거된다 (foo는 존재)
> 10. 더 이상 foo에 남은 것이 없으므로 호출 스택에서 제거된다
> 11. 이제 호출 스택이 완전히 비워졌다.
> 12. 이벤트 루프가 <span style="background-color:#fff5b1">호출 스택이 비워져 있다는 것을 확인</span>했다. 그리고 <span style="background-color:#fff5b1">태스크 큐를 확인하니</span> 4번에서 들어갔던 내용이 있어 bar()를 호출 스택에 들여보낸다.
> 13. bar()내부에 console.log가 있어 호출 스택에 들어간다
> 14. 13의 실행이 끝나고 다음 코드로 넘어간다. (아직 bar존재)
> 15. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다.<br>
<br>

`이벤트 루프`는 실행해야 할 태스크의 집합인 태스크 큐를 한 개 이상 가지고 있다.

💬 **정리** <br>
setTimeout과 같은 `외부 Web API`는 모두 브라우저나 <span style="background-color:#fff5b1">node js가 제공하는 별도의 스레드에서 관리</span>를 한다. 여기서 말하는 관리라는 것은 setTimeout을 예로 들어, 별도의 스레드에서 타이머가 시작되고 설정 시간이 지나면 콜백함수가 태스크 큐로 들어가게 하는 것을 말한다. <br> 이벤트 루프가 나중에 호출 스택이 비워지면 이 태스크 큐를 확인해서 실행시키는 것이다.<br><br>

### 1.5.3 태스크 큐와 마이크로 태스크 큐<br>
태스크 큐와 다르게, `마이크로 태스크 큐`라는 것도 있다.<br>
이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다. 대표적인 마이크로 태스크 큐에는 **Promise**가 있다. 이 <span style="background-color:#fff5b1">마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다.</span> 즉, setTimeout과 setInterval은 Promise보다 늦게 실행된다.<br>
<br>
<span style="color:gray">* 명세에 따르면, 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미루어진다.</span>
<br>
<br>

❓ 그럼 렌더링은 언제 실행될까 <br>
> 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.


