### 목차

- [2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션](#25-컴포넌트와-함수의-무거운-연산을-기억해-두는-메모이제이션)
  - [2.5.1 주장1 :섣부른 최적화는 독이다. 필요한 곳에만 메모이제이션을 추가하자](#251-주장1-섣부른-최적화는-독이다-필요한-곳에만-메모이제이션을-추가하자)
  - [2.5.2 주장2 : 렌더링 과정의 비용은 비싸기에 모두 메모이제이션해야한다.](#252-주장2--렌더링-과정의-비용은-비싸기에-모두-메모이제이션해야한다)
  - [2.5.3 결론 및 정리](#253-결론-및-정리)

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- 메모이제이션을 모든 곳에 사용하는것이 좋을까? 필요한 곳에만 사용하는 것이 좋을까?

## 2.5.1 주장1 :섣부른 최적화는 독이다. 필요한 곳에만 메모이제이션을 추가하자

- 메모이제이션도 비용이 드는 작업이다.

  - 최적화에 대한 비용을 지불할 때는 신중하게 해야 한다.

- 간단한 연산에 대해서는 메모이제이션을 사용하여 메모리 어딘가에 저장해두었다가 다시 호출하여 사용하는 것 보다, 바로 실행시키는 것이 더 빠를 수 있다.
- 메모이제이션은 마법 같은 기능이 아니다.

  - 그 자체로 비용이 든다.
  - 값을 비교하고 렌더링 또는 재계산이 필요한지 계산하는 작업비용
  - 이전의 결과물을 저장해 두었다가 다시 꺼내와야 하는 작업비용

- 모든 곳에 메모이제이션을 활용하는 것이 옳았다면, 리액트 개발 팀에서는 애초에 컴포넌트 생성자에 memo를 감싸두었을 것이다.

## 2.5.2 주장2 : 렌더링 과정의 비용은 비싸기에 모두 메모이제이션해야한다.

- 일부 컴포넌트에서는 섣부른 최적화인지 여부에 상관없이 메모이제이션을 하는 것이 성능에 도움이 된다.
- 렌더링이 자주 일어나는 컴포넌트거나, 렌더링 사이에 무거운 연산이 포함되있을 때, 메모이제이션은 이점이 있다.

- memo를 하지 않았을 때의 문제
  - 렌더링을 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두가지가 자식컴포넌트 까지 반복해서 일어나는 것
  - 리액트가 구 트리와 신 트리를 비교하는 것
  - ⇒ memo를 하지 않았을 때의 잠재적인 위험 비용이 더 크다.
- 리렌더링이 발생할 때, 메모이제이션과 같은 조치가 없다면, 모든 객체는 재생성 되고 결과적으로 참조는 달라지게 된다.

- 메모이제이션은 하지 않는 것보다 했을 때 더많은 이점을 누릴 수 있다는 주장
- 섣부른 초기화 일지라도, 누릴수 있는 이점이 존재하며, 메모이제이션을 하지 않았을 때 발생하는 위험비용보다, 처리해서 사용되지 않더라도 발생되는 비용이 더 적다는 주장이다.

## 2.5.3 결론 및 정리

- props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.
- 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다.
- 성능에 대해서 지속적으로 모니터링 하고 관찰하는 것보다, 섣부른 메모이제이션이 최적화가 주는 이점이 더 클 수 있다.
- 리액트를 깊이 이해하고 싶고, 현재 공부하는 중이라면, 어떤 부분에 최적화를 진행해야할지 주의깊게 살펴보면서 적용하는 것을 권장.
