### 목차

- [4.1 서버 사이드 렌더링이란?](#41-서버-사이드-렌더링이란)
  - [4.1.1 싱글 페이지 애플리케이션의 세상](#411-싱글-페이지-애플리케이션의-세상)
    - [싱글 페이지 애플리케이션이란?](#싱글-페이지-애플리케이션이란)
    - [전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교](#전통적인-방식의-애플리케이션과-싱글-페이지-애플리케이션의-작동-비교)
    - [싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장](#싱글-페이지-렌더링-방식의-유행과-jam-스택의-등장)
    - [새로운 패러다임의 웹서비스를 향한 요구](#새로운-패러다임의-웹서비스를-향한-요구)
  - [4.1.2 서버 사이드 렌더링이란?](#412-서버-사이드-렌더링이란)
    - [서버 사이드 렌더링의 장점](#서버-사이드-렌더링의-장점)
    - [SSR의 단점](#ssr의-단점)
  - [4.1.3 SPA와 SSR을 모두 알아야 하는 이유](#413-spa와-ssr을-모두-알아야-하는-이유)
    - [서버 사이드 렌더링 역시 만능이 아니다.](#서버-사이드-렌더링-역시-만능이-아니다)
    - [SPA와 SSR 애플리케이션](#spa와-ssr-애플리케이션)
    - [현대의 서버 사이드 렌더링](#현대의-서버-사이드-렌더링)

# 4.1 서버 사이드 렌더링이란?

기본적으로 SSR은 SPA의 제작 보다 신경쓸점이 훨씬 더 많다.

## 4.1.1 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 애플리케이션이란?

- 렌더링과 라우팅에 필요한 대부분의 기능을 `브라우저의 JS에 의존하는` 방식이다.
- 최초에 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 브라우저의 history.pushState와 history.replaceState로 이루어 진다.
  - 페이지를 불러온 이후에는 HTML을 내려받지 않고, 하나의 페이지에서 모든 작업을 처리한다.
- 실제 SPA로 구축된 페이지의 HTML 소스코드를 확인해보면 body에 아무런 내용이 없다.
  - body 내부의 내용을 모두 JS코드로 삽입한 이후에 렌더링하기 때문
  - 페이지 전환 시, JS에서 다음 페이지의 렌더링에 필요한 정보만 HTTP 요청등으로 가져 온 후, 해당 결과를 바탕으로 body내부에 DOM을 추가,수정,삭제하는 방법으로 페이지가 전환됨
- 최초에 로딩해야할 JS를 전부 로딩한 이후에는 서버를 거쳐 가져올 리소스가 적어 UI/UX적 이점이 있다.

### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

- SSR (기존의 렌더링 방식)
  - 페이지 전환 발생 시, 새롭게 페이지를 요청 → HTML 페이지를 다운로드하여 파싱
  - 위의 과정으로 인해 페이지가 새롭게 작성되는 대기 시간이 발생 한다.
- CSR (SPA 렌더링 방식
  - 최초에 한번 모든 리소스를 다운로드 한후, 페이지 전환에 필요한 추가 리소스를 다운받을 필요가 없어진다.
  - 페이지 전환에 필요한 일부 영역만 다시 그리게 되므로 매끄러운 UI를 제공할 수 있다.
  - ex ) Gmail

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- 과거 PHP나 JSP를 기반으로 대부분의 웹 애플리케이션은 렌더링이 서버 사이드에서 이루어졌다.
  - JS는 이 당시, 사용자에게 추가적인 기능, 경험을 주기위한 보조적인 수단이었다.
- 오늘날에는 많은 애플리에케이션이 JS를 제외하고는 페이지를 렌더링 하지 못할 정도로 JS에 대한 의존성이 높아졌다.
- JS SPA 프레임워크, 라이브러리의 발전은 FE 개발자에게 좀 더 간편한 개발자 경험을 제공했다.
  - 더욱 간편하게 혼자 애플리케이션을 만들 수 있는 장점이 생겼다.
- JAM 스택 (JavaScript, API, Markup)
  - 대부분의 작업을 JS에서 수행할 수 있게 된 상태
  - FE는 JS와 마크업(HTML, CSS)을 미리 빌드해두고, 정적으로 사용자에게 제공
    - → 모두 사용자의 클라이언트에서 실행 → 서버 확장성 문제 보완

### 새로운 패러다임의 웹서비스를 향한 요구

- JS에 대한 의존도가 상승함에 따라 애플리케이션의 JS 코드의 규모도 점차 커지기 시작했다.
- 웹 페이지를 불러오는데 필요한 부담을 사용자 기기의 발전에 맡기면 된다는 의견이 분분했다.
  - JS 파싱을 위해 CPU를 소비하는 시간이 증가했다. ⇒ 처리해야할 JS 크기가 증가했다의 증거
- 사용자 기기와 인터넷 속도 등, 웹 환경이 개선됐음에도 실제 사용자들이 느끼는 로딩 속도는 크게 달라지지 않았다.

## 4.1.2 서버 사이드 렌더링이란?

- 최초에 사용자에게 보여줄 페이지를 `서버에서 렌더링` 해 빠르게 사용자에게 화면을 제공
- SPA와의 중요한 차이는 `렌더링의 책임을 어디에 두느냐에 있다.`
- SSR은 렌더링에 필요한 작업을 모두 서버에서 수행한다.
  - 서버의 성능에 영향을 받는다.

### 서버 사이드 렌더링의 장점

- `최초 페이지 진입이 비교적 빠르다.`
  - 페이지의 유의미한 정보가 그려지는 시간이 더 빨라질 수 있다.
  - 서버에서 HTML을 문자열로 그려서 내려주는 것이 클라이언트에서 기존의 HTML 에 새 요소를 삽입하는 것보다 빠르다.
  - 화면 렌더링이 HTTP 요청에 의존적이거나, 렌더링 해야할 HTML의 크기가 커진다면 상대적으로 SSR이 더 빠를 수 있다.
  - 이 모든 것은 서버의 리소스가 충분하다는 전제에서 성립한다.
- `검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.`
  - SSR은 검색 엔진 최적화에 유용하다.
  - 검색 엔진이 사이트에서 정보를 가져가는 과정
    1. 검색 엔진 로봇이 페이지에 진입
    2. 페이지가 HTML 정보를 제공
    3. 로봇은 제공받은 HTML을 다운받되, `JS 코드는 실행하지 않는다.`
    4. 다운로드한 HTML 내부의 Open Graph나 meta tag 정보르 기반으로 페이지의 검색정보를 가져오고 검색 엔진에 저장한다.
  - 검색 엔진은 페이지 내부의 JS 코드를 실행하지 않게 SPA가 SEO 이점이 적다는 것
    - 로봇은 페이지의 `정적 정보` 를 가져오는 것이 목적
  - SSR은 최초의 렌더링 작업이 서버에서 일어난다.
    - 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML응답이 가능
    - ⇒ 검색 엔진 최적화 대응 가능
- `누적 레이아웃 이동이 적다`

  - 누적 레이아웃 이동
    - 페이지가 표시 된 뒤, 일부분의 HTML 정보가 수정 및 변경되어 화면이 덜컥 거리는 현상.
  - SPA는 페이지 콘텐츠가 API에 의존적이므로, 그 응답 속도에 따라 누적 레이아웃 이동이 발생할 가능 성이 높다.
  - SSR은 이런 API를 사용해도, 그 응답이 모두 완료된 후에 페이지를 렌더링 하므로 해당 위험이 적다.

- `사용자 디바이스 성능에 비교적 자유롭다`
  - JS 리소스 실행은 사용자 기기에서 실행 되므로 절대적으로 사용자 기기의 성능에 의존한다.
  - SSR은 렌더링 부담을 서버에 나눌수 있으므로 사용자 기기의 성능으로부터 좀 더 자유롭다.
    - 사용자가 급증하거나 리소스가 부족하면 서버의존적인 SSR 또한 성능 저하가 발생한다.
- `보안에 좀 더 안전하다`
  - SPA의 공통적인 문제점은 애플리케이션의 모든 활동이 브라우저에 노출되는 점이다.
  - SSR은 인증 또는 민감한 작업을 서버에서 수행하고 결과만 브라우저에 제공하므로 이러한 보안적 장점이 있다.

### SSR의 단점

SSR 또한 만병통치약은 아니다..

- `소스코드 작성 시, 항상 서버를 고려해야 한다`

  - 소스 코드 전반에 걸쳐 서버 환경에 대한 고려가 필요하다.
  - 브라우저 전역 객체에 대한 사용에 주의 해야 한다.
  - 잠재 위험을 가진 모든 코드를 브라우저에서 실행하는 것 또한 해결책은 아니다.
  - ⇒ Client 에서 실행되는 코드가 많을 수록 SSR의 이점은 사라진다.

- `적절한 서버가 구축돼 있어야 한다.`
  - SSR은 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하다.
    - 물리적인 가용량 확보 필요
    - 장애 복구전략 수립
    - 요청 분산 설계
    - 프로세스 다운 대비
- `서비스 지연에 따른 문제`
  - SPA는 지연된 작업이 있더라도, 어떤 화면이라도 보여준 상태에서 느린 작업을 수행하므로 사용자가 인지할 수 있다.
    - 로딩 컴포넌트를 표시하는 방법을 사용해 인지 시킬 수도 있다.
  - SSR은 서버에서 렌더링을 위한 작업이 모두 끝나기 전까지는 렌더링을 하지 않는다.
    - 병목현상이 발생한다면, 더 안좋은 사용자 경험을 제공할 수도 있다.

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

- SSR 또한 SPA와 같이 모든 문제의 해결책이 될 수는 없다.

### 서버 사이드 렌더링 역시 만능이 아니다.

- 잘못된 웹페이지 설계(SSR에서)는 실질적으로 SSR의 성능적 이점을 활용할 수 없고 역효과 까지 나을 수 있다.
- 사용자에게 제공하고 싶은 내용과, 어떤 우선순위로 페이지의 내용을 보여줘야 할 지 잘 설계해야 한다.
- 우선순위 따라 SPA가 더 효율적일 수도 있다.

### SPA와 SSR 애플리케이션

1. 가장 뛰어난 SPA는 가장 뛰어난 MPA 보다 낫다
2. 평균적인 SPA는 평균적인 MPA 보다 느리다.

- 평균적인 노력으로 만들어내는 서비스라면, MPA가 SPA보다 우위에 있을 수 있다.
- 현재까지도 두 영역 모두 단점을 보완하기 위해 발전하는 중이다.

### 현대의 서버 사이드 렌더링

- 기존의 LAMP 방식과는 다르다.
- 최초 페이지 진입시에 서버에서 렌더링을 진행에 이미 완성된 HTML을 제공
- 라우팅 시, 서버에서 내려받은 JS를 바탕으로 SPA처럼 작동한다.
- FE 개발자는 서버, 클라이언트에서의 렌더링을 모두 이해하여 두 가지의 장점을 완벽하게 취하는 웹서비스를 구축해야 한다.
