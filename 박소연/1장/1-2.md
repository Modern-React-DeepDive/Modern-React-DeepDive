## 💡 1.2. 함수

### 📌 1.2.1. 함수란 무엇인가?

함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

```javascript
funciton sum(a, b){
    return a+b
}

sum(10, 20)
```

- 매개변수: 함수의 입력값으로 받는 a, b
- 반환값: return 으로 작성된 것
- 인수: 함수의 이름을 사용해 함수를 호출하는데 sum뒤에 넘겨준 두 개의 값 10, 20

<br />

### 📌 1.2.2. 함수를 정의하는 4가지 방법

<span style="background-color:#f5f0ff">**함수 선언문**</span>

```javascript
function add(a, b) {
  return a + b;
}
```

함수 선언문은 표현식이 아닌 일반 문(statement)로 분류된다.

> 표현식이란? <br />
> 값을 산출하는 구문을 의미

즉, 함수 선언문으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류되는 것이다.

```javascript
const sum = function add(a, b) {
  return a + b;
};

sum(10, 20);
```

하지만 위의 예시처럼 함수를 변수에 할당하게 되면 표현식과 같은 작동을 보인다.

이는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.

따라서 위와 같이 이름을 가진 형태의 함수 리터럴은 코드 문맥에 따라 전자와 같은 선언문으로도, 후자와 같은 표현식으로도 사용될 수 있음을 알고 있어야 한다.

<br />

<span style="background-color:#f5f0ff">**함수 표현식**</span>

함수 표현식에 대해 알아보기 전에 **일급 객체**에 대해서 먼저 알아보자.

> 일급 객체란? <br />
> 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. <br />
> 자바스크립트에서 함수는 다른 함수의 매개변수가 될 수도 있고 반환값이 될 수도 있으며 앞에서 본 것처럼 할당도 가능하므로 일급 객첵 되기 위한 조건을 모두 갖추고 있다.

함수가 일급 객체이므로 함수를 변수에 할당하는 것도 당연히 가능한 것이다.

함수 표현식에서는 할당하려는 **함수의 이름을 생략하는 것**이 일반적이다.

```javascript
const sum = function add(a, b) {
  console.log(arguments.callee.name);
  return a + b;
};

sum(10, 20); // add
add(10, 20); // add is not defined
```

그 이유는 혼란을 방지하기 위해서인데 위의 예시를 보면 함수를 호출하기 위해서 사용된 것은 **sum**인 것을 알 수 있다.

그리고 add는 실제 함수 내부에서만 유효한 식별자일 뿐, 함수를 외부에서 호출하는 데에는 사용할 수 없는 식별자다.

> ❗️함수 표현식과 선언 식의 차이 <br />
> 이 두 가지 방식의 가장 큰 차이는 호이스팅(hoisting)여부다.<br />
> ❗️호이스팅이란? <br />
> 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징이다. <br />

```javascript
hello(); // hello

function hello() {
  console.log("hello");
}

hello(); // hello
```

위의 예시를 보면 함수는 중간에 선언되어 있지만 맨 앞에서 함수를 호출했어도 에러없이 잘 작동하는 것을 볼 수 있다. <br/>
함수의 호이스팅은 함수에 대한 **선언**을 실행 전에 미리 **메모리에 등록하는 작업**을 의미한다. <br />
이 특징 덕분에 함수 선언문이 미리 메모리에 등록됐고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된 것이다.

반면 함수 표현식은 함수를 변수에 할당했다. 변수도 마찬가지로 호이스팅이 발생한다. <br>
그러나 함수의 호이스팅과는 다르게 호이스팅되는 시점에서 `var`의 경우 `undefined`로 초기화한다는 차이가 있다.

```javascript
console.log(typeof hello === "undefined"); // true

hello(); // TypeError: hello is not a function

var hello = function () {
  console.log("hello");
};

hello(); // hello
```

- 함수가 할당되어 있는 변수 hello가 호이스팅되어 최상단으로 올라감
- 하지만 함수의 내용은 같이 호이스팅되지 않고 hello에 대한 값이 `undefined`로 초기화된다.

<br>

<span style="background-color:#f5f0ff">**Function 생성자**</span>

```javascript
const add = new Function("a", "b", "return a+b");

add(10, 20);
```

`Function`생성자를 사용할 경우 매개변수부터 함수의 모든 것을 문자열로 작성해야 한다. <br>
이는 코드의 양이 길어진다면 더욱 혼란스러워질 수 있다. <br>
또한, 이렇게 생성자 방식으로 함수를 만들면 함수의 클로저 또한 생성되지 않는다.<br>
따라서 이렇게 함수를 생성하는 것은 권장되지 않는다.

<br>

<span style="background-color:#f5f0ff">**화살표 함수**</span>

화살표 함수는 ES6에서 도입된 방식으로 최근들어 개발자들이 가장 많이 사용하는 방식이다. <br>
`function`이라는 키워드 대신에 `=>`화살표를 사용해 함수를 만드는데 이러면 타이핑할 글자가 줄어든다는 측면에서 많이 사용된다고 생각한다.

```javascript
const add = (a, b) => {
  return a + b;
};

// 또는

const add = (a, b) => a + b;
```

<br>

- 화살표 함수에서는 `constructor`를 사용할 수 없다.
  - 생성자 함수로 화살표 함수를 사용할 수 없다.

```javascript
const Car = (name) => {
  this.name = name;
};

const myCar = new Car("하이"); // TypeError: Car is not a constructor
```

- ❗️`this`바인딩의 차이
  - `this`란 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
  - 화살표 함수 이전까지 `this`는 함수를 정의할 때 결정되는 것이 아니라 **함수가 어떻게 호출되느냐에 따라 동적으로 결정된다**
  - 만약 함수가 일반 함수로서 호출된다면 그 내부의 `this`는 전역 객체를 가리키게 된다.
  - 그러나, **화살표 함수는 함수 자체의 바인딩을 가지지 않는다.**
  - 화살표 함수 내부에서 `this`를 참조하면 상위 스코프의 `this`를 그대로 따르게 된다.
  - 화살표 함수는 `this`가 **선언되는 시점에 이미 상위 스코프로 결정돼 있어 미리 받아 사용**하지만, 일반 함수는 호출하는 **런타임 시점에 결정되는 `this`를 그대로 따른다.**

<br>

### 📌 1.2.3. 다양한 함수 살펴보기

<span style="background-color:#f5f0ff">**즉시 실행 함수**</span>

즉시 실행 함수는 일반적으로 IIFE라고 부른다. <br>
말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.<br>
**단 한 번만 호출되고, 다시금 호출할 수 없는 함수이다.**

```javascript
(function(a, b){
    return a+b
})(10, 20); // 34

((a, b) => {
    return a+b
},)(10, 20) // 30
```

- 즉시 실행 함수는 한 번 선언하고 호출된 이후부터는 재호출이 불가능하다.
- 일반적으로 즉시 실행 함수는 이름을 붙이지 않는다.
- 독립적인 함수 스코프를 운용할 수 있다.
- 함수 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능하다.

<br>

<span style="background-color:#f5f0ff">**고차 함수**</span>

자바스크립트 함수는 일급 객체이기 때문에 함수를 인수로 받거나 결과로 새로운 함수를 반환할 수 있다. <br>
이런 역할을 하는 함수를 **고차 함수(Higher Order Function)**이라고 한다.

```javascript
// 함수를 반환하는 고차함수
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a + b;
  };
};

add(1)(3); // 4
```

<br>

### 📌 1.2.4. 함수를 만들 때 주의해야 할 사항

**함수의 부수 효과를 최대한 억제하라**

> 함수의 부수 효과(side-effect)란? <br>
> 함수의 부수 효과란 함수 내의 작동으로 인해 함수가 아닌 함수의 **외부에 영향을 끼치는 것**을 의미한다.
> 이러한 **부수 효과가 없고 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환하는 함수를 순수 함수**라고 한다.
> 또한, 이러한 작동 와중에 외부에 어떠한 영향도 미쳐서는 안 된다.

<br>

**가능한 한 함수를 작게 만들어라**

함수당 코드의 길이가 길어질수록 코드 냄새(문제를 일으킬 여지가 있는 코드)가 날 확률이 커지고, 내부에서 무슨 일이 일어나는지 추적하기 어려워진다.

> 🔗 ESLint: max-lines-per-function <br>
> 기본값으로 50줄 이상 넘어가면 과도하게 커진 함수로 분류하고 경고 메시지를 출력한다. <br>
> 그 외에 중첩이 얼마나 많이 있고 콜백은 얼마나 많은지도 이 규칙에서 확인할 수 있다.

즉, 하나의 함수에서 너무나 많은 일을 하지 않게 하는 것이다. <br>
함수는 하나의 일을 잘하게 하는 것이 원래 함수의 목적인 재사용성을 높일 수 있는 방법이다.

**누구나 이해할 수 있는 이름을 붙여라**

점차 코드가 커지고 비즈니스 로직이 들어가는 코드가 많아질수록 더욱 어려움에 빠지게 된다. <br>
클린 코드나 리팩터링 측면을 위해서도 가능한 한 함수 이름을 간결하고 이해하기 쉽게 붙이는 것이 좋다.
