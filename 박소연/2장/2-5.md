## 💡 2.5. 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

많은 사람들이 이 세 가지가 모두 최적화 기법에 사용된다는 것은 알고 있지만 정확히 언제 사용하는 지에 대해서는 모르는 경우가 많다.

메모이제이션 최적화와 관련해 두 가지의 주장이 존재하는데 이에 대해 정확히 알아보자.

<br>

### 📌 2.5.1. 주장1 : 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자

먼저 **꼭 필요한 곳을 신중히 골라서 메모이제이션**해야 한다는 입장이다.

메모이제이션도 결국은 비용이 발생하는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다고 주장한다.

```javascript
function sum(a, b) {
  return a + b;
}
```

위와 같이 매우 간단한 연산을 수행하는 함수가 있다고 했을 때, 이 결과를 메모이제이션 하는게 좋을까 아니면 매번 새로운 계산을 하는게 좋을까?

위의 작업처럼 가벼운 작업 자체는 메모이제이션해서 메모리 어딘가에 넣어 두었다가 다시 꺼내오는 것보다 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수 있다.

위에서도 언급했듯이 결국 메모이제이션에도 비용이 든다.

- 값을 비교
- 렌더링 또는 재계산이 필요한지 확인
- 이전 결과물을 저장했다가 다시 꺼내오는 작업

위와 같은 비용들이 발생하게 되는데 과연 이 비용이 리렌더링 비용보다 저렴하다고 할 수 있을까?

이는 상황에 따라 다를 것이다. 따라서 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 **경계**해야 한다.

<br>

### 📌 2.5.2. 주장2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다. <br> 섣부른 최적화인지 여부와는 관계없이 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명 있다.

이런 경우 우리는 두 가지 선택권이 있다.

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 <u>일부에만</u> 적용하는 방법
- memo를 일단 <u>그냥 다</u> 적용하는 방법

<br>

**memo를 일부에만 적용할 경우**

이 경우는 가장 이상적인 상황이라고 할 수 있다.<br>

memo로 우선 감싼 후에 비용적인 측면에 대해서 생각해보자. <br>
즉, 렌더링 비용이 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 memo를 써서 오히려 비용을 지불해야 하는 경우를 생각해보자.

<br>

---

**잘못된 memo**를 사용해 질불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.

메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.<br>
리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다.

이게 우리가 앞에서 배웠던 **리액트의 재조정 알고리즘**이기 때문이다. <br>
즉, 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있는 것이다!

따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다.

<br>

반면, memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

위처럼 비교를 해봤을 때 **memo를 하지 않았을 때 처리해야 할 잠재적인 위험 비용이 더 크다.**

---

그럼 useMemo, useCallback을 사용했을 때는 어떨까?

이 훅들을 사용해서 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다.

> ❗️ 만약 메모이제이션과 같은 별도 조치를 하지 않는다면? <br>
> 아무 조치를 하지 않는다면 모든 객체는 재생성되고 결과적으로 참조가 달라지게 된다. <br>
> 이 참조에 대한 값을 어디서든 쓰지 않는다면 큰 문제가 되지 않을 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이게 된다면 달라지는 참조로 인해 다른 쪽에도 여향을 미칠 수 있다.

<br>

즉, 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 참조 투명성을 유지할 수 있고 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

결국 메모이제이션은 하지 않는 것보다 메모이제이션 했을 때 더 많은 이점을 누릴 수 있다.

<br>

### 📌 2.5.3. 결론 및 정리

만약 현업에서 리액트를 사용하고 있거나 성능에 대해서 깊이 연구할 시간이 없는 상황이라면 의심스러운 곳에는 우선 다 적용해보자.

props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.

조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 매우 크다!
