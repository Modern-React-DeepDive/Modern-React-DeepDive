# 📚 5장. 리액트와 상태 관리 라이브러리

## 💡 5.1. 상태 관리는 왜 필요한가?

웹 애플리케이션에서 상태로 분류될 수 있는 것들은 다음과 같다

- UI: 웹 애플리케이션에서 상호 작용이 가능한 모든 요소의 현재 값. 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
- URL: 브라우저에서 관리되고 있는 상태값. 사용자의 라우팅에 따라 변경이 가능한 url에서 쿼리스트링으로 받아오는 경우가 이에 해당한다.
  - ex. http://~~~/rooms/384758?adults=2
  - 위와 같은 주소가 있다고 하면 roomId=384758, adults=2라고 하는 상태가 존재하는 것이다.
- 폼(form): 로딩중(loading)인지, 현재 제출됐는지(submit), 접근이 불가능한지(disabled), 값이 유효한지(validation) 등 모두가 상태로 관리된다.
- 서버에서 가져온 값:클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다. ex. API 요청

우리는 이러한 상태가 변화함에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상(=treating)을 방지해야 한다.
이를 위해서 이러한 상태를 효율적으로 관리하고 상태가 필요한 쪽에서는 빠르게 반응할 수 있는 모델에 대한 고민이 시작된 것이다.

### 📌 5.1.1. 리액트 상태 관리의 역사

우리가 순수 리액트에서 상태를 관리하려면, 특히 전역 상태 관리를 하는 방법이라고 하면 ContextAPI가 있다.
하지만 ContextAPI는 상태 관리가 아니라 **상태 주입**을 도와주는 역할이다.

**🔗 MVC 패턴과 Flux 패턴의 등장**

기존의 MVC패턴에서는 뷰(HTML)가 모델(js)을 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경할 수 있다. <br>
즉, 양방향 데이터 바인딩으로 모델과 뷰가 많아질수록 복잡도가 증가하게 된다. <br>
이는 코드를 작성하는 입장에서는 간단할 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워진다.

페이스북팀은 이를 문제의 원인으로 봤다.<br>
이후 페이스북팀은 양방향이 아닌 **단방향**으로 데이터 흐름을 변경하는 것을 제안하는데 이게 **Flux패턴**이다. <br>

> 🖍️ Flux 패턴에서의 용어
>
> - action : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. **액션 타입과 데이터를 각각 정의해 이를 dispatcher로 보낸다.**
> - dispatcher : **액션을 스토어에 보내는 역할**을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
> - store : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 **메서드**를 가지고 있다. **액션의 타입에 따라 어떻게 이를 변경할지가 정의**돼 있다.
> - view : 리액트 컴포넌트에 해당하는 부분으로 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다.
>   - 뷰에서도 사용자의 입력이나 행위에 따라서 상태를 업데이트하고자 할 수 있을 것이다. 이경우에는 뷰에서 액션을 호출하는 구조로 구성된다.
>   - 뷰에서 액션 호출 → 액션은 타입과 데이터를 디스패처로 보낸다 → 디스패처는 다시 스토어에 액션을 보낸다 → 스토어에서 데이터를 만들고 뷰가 렌더링한다.

이러한 단방향 데이터 흐름 방식은 당연히 불편함도 존재한다. <br>
사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 **코드의 양이 많아지고 개발자도 수고**스러워진다. <br>

하지만 데이터의 흐름은 모두 액션이라는 **한 방향(단방향)**으로 줄어들므로 **데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 한결 수월**해진다!

<br>

---

<br>

**🔗 시장 지배자 리덕스의 등장**

리덕스는 위에서 배운 Flux구조를 구현하기 위해 만들어진 라이브러리 중 하나였다. <br>
한 가지 특별한 점은 여기에 Elm아키텍처를 도입했다는 것이다.

> 📚 Elm이란? <br>
> : 웹페이지를 선언적으로 작성하기 위한 언어
>
> - model : 애플리케이션의 상태를 의미한다
> - view : 모델을 표현하는 HTMl
> - update : 모델을 수정하는 방식

→ 즉, Elm은 Flux와 마찬가지로 데이터 흐름을 **세 가지로 분류**하고 이를 **단방향으로 강제**해 웹 애플리케이션의 **상태를 안정적으로 관리**하고자 노력했다. <br> 그리고 리덕스는 이 Elm아키텍처의 영향을 받아 작성됐다.

<br>

**리덕스는**

- 하나의 상태 객체를 스토어에 저장해둔다.
- 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다.
- 이러한 작업은 reducer함수로 발생시킬 수 있다.
- 이 함수는 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파한다.

<br>

**😞 리덕스의 단점**

- 하나의 상태를 바꾸기 위해 해야 할 일이 너무 많다.
- 우선 어떠한 액션인지 타입을 선언해야 한다.
- 이 액션을 수행할 creator 함수를 만들어야 한다.
- 그리고 dispatcher와 selector도 필요하다.
- 또한, 새로운 상태가 어떻게 기존의 reducer내부에서 어떤 식으로 변경돼야 할 지, 혹은 새로 만들어야 할 지도 정의해야 했다.

<br>

---

<br>

**🔗 ContextAPI와 useContext**

리액트가 처음 생겨났을 때 상태를 어떻게 적절하게 주입해야 하는지에 대한 고민이 있었다. <br>
이른바 부모에 있는 상태를 자식 컴포넌트에 쓰기 위해서는 prop내려주기라 불리는 방식, 즉 **props를 가지고 있는 부모에서 필요한 자식 컴포넌트까지 끊임없이 컴포넌트의 인수로 넘겨야 하는 불편함이 있었다. (=props drilling문제)**

이러한 문제는 컴포넌트의 깊이가 깊어질수록 더욱 문제가 되었고 여기에 리덕스를 적용하기에는 단순히 상태를 참조하고 싶을 뿐인데 준비해야 하는 보일러플레이트도 부담스러웠다.

그렇게 등장하게 된 것이 **ContextAPI**이다.

**ContextAPI는 전역 상태를 하위 컴포넌트에 주입할 수 있다.** <br>
props로 상태를 넘겨주지 않더라도 ContextAPI를 사용하면 원하는 곳에서 Context Provider가 제공하는 상태를 사용할 수 있다.

여기서 중요한거는 ContextAPI는 상태 관리가 아니라 **상태 주입**을 도와주는 것이라는 걸 인지해야 한다. <br>
렌더링을 막아주는 부가적인 기능 또한 없기 때문에 사용할 때 주의가 필요하다.

<br>

---

<br>

**🔗 훅의 탄생, 그리고 React Query와 SWR**

이번에는 React Query와 SWR에 대해 알아보자.

이 두 가지 라이브러리는 모두 외부에서 데이터를 불러오는 **fetch를 관리하는 데 특화된 라이브러리**이다. <br>
하지만 **API호출에 대한 상태를 관리하고 있기 때문에 HTTP요청에 특화된 상태 관리 라이브러리**라고 볼 수 있다.

[useSWR사용 예시]

```javascript
import React from 'react'
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

export default function App = () => {
    const {data, error} = useSWR('https://api.~~', fetcher,)

    if(error) {
        return 'error'
    }

    if(!data){
        return 'loading...'
    }

    return(
        <div>
            <p>{JSON.stringify(data)}</P>
        </div>
    )
}
```

**useSWR**

- 첫 번째 인수로 조회할 **API주소**
  - 첫 번째 인수인 API 주소는 **키**로도 사용
  - 이후에 다른 곳에서 동일한 키로 호출하면 재조회하는 것이 아니라 **useSWR이 관리하고 있는 캐시의 값을 활용**
- 두 번째 인수로 조회에 사용되는 **fetch**
