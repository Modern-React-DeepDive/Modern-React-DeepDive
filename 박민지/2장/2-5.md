# 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

`메모이제이션`이란?

- 컴퓨터가 동일한 계산을 반복해서 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산을 하지 않게 하여 속도를 높이는 것이다. 어플리케이션 최적화에 사용한다.

## 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

메모이제션은 비용이 드는 작업이기 때문에 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다.

### 메모이제이션에서의 비용

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 작업

상황에 따라 리렌더링 비용과 메모이제이션 비용은 달라질 것이다.
즉, 메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이다.

따라서 모든 컴포넌트를 pureComponent로 만들거나 memo로 감싸두는 작업은 성능개선이 모두 다 좋은 것은 아니다.

공식문서에서는 아래와 같이 이야기 한다.

> useMemo는 성능 최적화를 위해 사용할 수는 있지만 의미상으로 그것이 보장된다고 생각하지는 마세요. 가까운 미래에 리액트에서는 이전에 메모이제이션된 값들의 일부를 "잊어버리고" 다음 렌더링 시에 그것들을 재계산하는 방향을 택할지도 모르겠습니다. 예를 들면, 오프스크린 컴포넌트의 메모리를 해제하는 등이 있을 수 있습니다. `useMemo를 사용하지 않고도 작동할 수 있도록 코드를 작성하고 그것을 추가해 성능을 최적화`하세요.

## 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

### 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다.

- 해당 컴포넌트가 렌더링이 자주 일어남
- 그 렌더링 사이에 비싼 연산이 포함되어 있음
- 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있음

-> 이럴 땐 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명히 있다.

#### 모조리 메모이제이션을 한다면 잘못된 컴포넌트에 이뤄진 최적화에 대한 비용을 생각해야 한다.

- 즉, 렌더링 비용이 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 Memo를 썼을 때 역으로 지불해야 하는 비용을 생각해야 한다.
- 잘못된 Memo로 지불해야하는 비용은 바로 Props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.
  - 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리랜더링할 필요가 없다면 이전 결과물을 사용해야 한다.
  - 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해야 한다. (재조정 알고리즘때문에)
  - 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물을 어떻게든 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props애 대한 얕은 비교인 것 뿐이다.

### memo를 하지 않았을 때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교
