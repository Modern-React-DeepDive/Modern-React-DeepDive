# 2.2 가상 DOM과 리액트 파이버

리액트는 실제 DOM이 아닌 가상 DOM을 운영한다!

# 2.2.1 DOM과 브라우저 렌더링 과정

### DOM(Document Object Model)이란?

DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고있음

#### 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 `HTML 파일을 다운로드` 한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 `DOM 노드로 구성된 트리(DOM)`를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 `CSS 파일도 다운로드`한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 `CSS 노드로 구성된 트리(CSSOM)`를 만든다.
5. 브라우저는 2번에서 만든 `DOM 노드를 순회`하는데, 여기서 모든 노드를 방문하지 않고 display:none 과 같이 사용자 화면에 보이지 않는 요소는 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견된 `CSS 스타일 정보를 이 노드에 적용`한다.

##### DOM 노드에 CSS를 적용하는 과정

- 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이후 페인팅 과정도 거친다
- 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

## 2.2.2 가상 DOM의 탄생 배경

렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황은 존재

1. 특정한 요소의 색상이 변경되는 경우 (페인팅만 일어나 빠른 처리 가능)
2. 특정한 요소의 노출 여부가 변경되거나 사이즈가 변경되는 등 요소의 위치와 크기를 재계산하는 경우 (레이아웃 -> 페인팅의 과정을 수행하기에 더 많은 비용이 듦)
3. DOM 변경이 일어나는 element가 많은 자식 element를 가지고 있는 경우, 하위 자식 element도 더 많은 비용을 브라우저와 사용자가 지불해야 한다.

- SPA(Single Page Application)의 경우, `하나의 페이지에서 모든 작업이 일어나 렌더링 이후 추가 렌더링 작업이 더욱 많아짐`. 하나의 페이지에서 계속 요소의 위치를 재계산 하기 때문. 이러한 특징으로 사용자는 깜빡임 없이 웹페이지 탐색이 가능하지만, `DOM 관리의 입장에서는 부담할 비용이 커짐`

### 가상 DOM

- 이러한 문제를 해결하기 위해서 가상 DOM이 나오게 됨
- 이는 말 그대로 실제 브라우저의 DOM이 아니라 리액트가 관리하는 가상의 DOM을 의미
- 가상 DOM은 `웹페이지가 표시할 DOM을 메모리에 저장`하고, `react-dom이 실제 변경에 대한 준비가 완료 되었을 때 실제 브라우저의 DOM에 반영`.

### 가상 DOM에 대한 오해

가상 DOM은 일반적인 DOM을 관리하는 브라우저보다 무조건 빠른 것은 아님.
이는 대부분의 상황에서 웬만한 어플리케이션을 만들 수 있을 정도로 합리적으로 빠르다고 이해하는 것이 좋다.

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 리액트 파이버(React Fiber)다.

### 리액트 파이버

- 리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체
- `파이버 재조정자(fiber reconciler)`가 관리
- 가상 DOM과 실제 DOM을 `비교`하여 변경 사항을 수집
- `만약 둘 사이에 차이가 있으면` 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

  #### 재조정

  리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

---

리액트 파이버는 웹 앱에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이 목표다. 이를 위해 다음의 일을 한다.

- 작업을 작은 단위로 분할, 쪼갠 다음, 우선 순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요치 않은 경우 폐기할 수 있다.
- 이러한 모든 과정은 `비동기`로 일어난다.

---

파이버는 하나의 작업 단위로 구성돼 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 이 작업을 커밋하여 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. 해당 단계는 아래 두단계로 나뉜다.

1. `랜더 단계`에서 리액트는 사용자에게 노출되지 않는 모든 ‘비동기 작업’을 수행한다. 이 단계에 앞서 언급한 파이버의 작업, 우선순위를 지정, 중지, 버리는 등의 작업이 일어난다.
2. `커밋 단계`에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업. commitWork()가 실행되는데, 이 과정은 앞서와 다르게 ‘동기식’으로 일어나고 중단될 수도 없다.

### 리액트 파이버 트리

1. 현재 모습을 담은 파이버 트리
2. 작업 중인 상태를 나타내는 workInProgress 트리

### 더블 버퍼링

리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경하여 workInProgress 트리를 현재 트리로 바꾼다. 이러한 작업을 ‘더블 버퍼링’이라고 한다.

- 더블 버퍼링은 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 의미한다.

### 파이버의 작업 순서

1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그 다음 `completeWork()` 함수를 실행하여 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.
