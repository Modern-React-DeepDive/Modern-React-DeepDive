# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교

- 리액트와의 연결점
  - 리액트 컴포넌트의 렌더링이 일어나는 이유 : props의 동등비교의 결과
  - 리액트의 가상 DOM과 실제 DOM의 비교, 리액크 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 **자바스크립트의 동등 비교** 를 기반으로 함.

<br>

- 얕은 비교란?
  - 숫자, 문자열 등 원시 자료형은 값을 비교
  - 배열, 객체 등 참조 자요형은 값 혹은 속성은 비교하지 않고, 참조되는 위치를 비교
  - cf. 깊은 비교는 객체의 경우에도 값을 비교

<br>

### 1.1.1 자바스크립트의 데이터 타입

1. 원시타입(primitive type)
2. 객체타입(object/reference type)

### 1.1.2 값을 저장하는 방식의 차이

원시타입과 객체타입의 가장 큰 차이점 : 값을 저장하는 방식 -> 동등 비교를 할 때 차이를 만드는 원인

- 원시타입
  - 불변 형태의 값으로 저장
    - 불변 형태의 값이란?
    -
  - 해당 값은 변수 할당 시점에 메모리 영역을 차지하고 저장됨

<br>

- 객체타입
  - 프로퍼티를 삭제, 추가, 수정할 수 있음
  - 변경 가능한 형태로 저장됨
  - 값을 복사해도 값이 아닌 참조를 전달
  - 객체마다의 주소는 다르지만 value가 가리키는 주소는 동일하다.

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

**Object.is** 는 두 개의 인수를 받으며, 두 개가 동일한지 확인하고 반환하는 메서드임
<br>

- == vs Object.is
  - == : 같은 타입으로 강제 형변환한 후 비교
  - Object.is : 형변환하지 않기 때문에 타입이 다르면 false
- === vs Object.is

  - Object.is가 더 정확히 비교

  ```
  -0 === +0 // true
  Object.is(-0. +0) // false

  Number.NaN === NaN // false
  Object.is(Number.NaN, NaN) // true

  NaN === 0/0 // false
  Object.is(NaN, 0/0) //true
  ```

- 단 Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다.

### 1.1.4 리액트에서의 동등 비교

리액트에서의 동등 비교는 ==나 ===가 아닌 Object.is이다.
<br>
Objet.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 함께 사용하고 런타임에 Object.is가 있다면 그것을 사용하고, 아니라면 is 함수 폴리필 사용

- 폴리필이란?

  - 브라우저에서 지원하지 않는 코드를 사용가능한 코드 조각이나 플러그인(추가기능)

- 리액트에서는 ObjectIs를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용 -> 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용
  <br>

[요약]

- 리액트에서는 Object.is로 먼저 비교를 수행한 다음, 객체 간 얕은 비교를 한 번 더 수행
- 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교

  ```
  Object.is({hello:'world'}, {hello:'world'}) //false

  shallowEqual({hello:'world'}, {hello:'world'}) //true

  shallowEqual({hello:{hi: 'world'}}, {hello:{hi: 'world'}}) //false
  ```

- 따라서 React.memo로 컴포넌트를 감싸준다고 했을때, 깊이가 깊은 매개변수가 있다면 랜더링 방지에 실패한다.

### 1.1.5 정리

- 자바스크립트의 객체 비교 불완전성은 다른 함수형 언어에서는 볼 수 없는 특징이기에 꼭 기억해야됌
- 자바스크립트를 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 이러한 언어적인 한계를 뛰어넘을 수 없으므로 얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현하고 있음
- 이를 잘 이해하면, 함수 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성, 렌더링 최적화를 위해서 꼭 필요한 React.memo를 올바르게 작동시키기 위해 고려해야할 것들을 쉽게 이해할 수 있을것임
