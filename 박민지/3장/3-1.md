# 3.1 리액트의 모든 훅 파헤치기

## 3.1.1 useState

useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅

```javascript
import { useState } from "react";

const [state, setState] = useState(initialState);
```

useState의 인수로는 사용할 state의 `초깃값`을 넘겨준다. `useStat 반환값`은 `배열`이며, `배열의 첫 번째 원소`로는 `state` 값이며, `두 번째 원소`로는 `setState 함수`를 사용해 해당 state의 값을 변경한다.

```javascript
function Componenet() {
  let state = "hello";

  function handleButtonClick() {
    state = "hi";
  }

  return (
    <>
      <h1>{state}</h1>
      <button onClick={handleButtonClick}>hi</button>
    </>
  );
}
```

위 코드는 동작하지 않는다. 렌더링은 함수 컴포넌트의 return과 클래스 컴포넌트의 render함수를 실행한 다음, 이 실행 결과를 이전의 리액트 트리오 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄지는데 위 코드에서는 리렌더링을 발생시키기 위한 조건을 전혀 충족하지 못하고 있다.

```javascript
function Componenet() {
  const [, triggerRender] = useState();

  let state = "hello";

  function handleButtonClick() {
    state = "hi";
    trigerRender();
  }

  return (
    <>
      <h1>{state}</h1>
      <button onClick={handleButtonClick}>hi</button>
    </>
  );
}
```

일부러 리렌더링을 시키더라도 state값은 변경되지 않을 것이다.

매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화되므로 아무리 state를 변경해도 다시 hello로 초기화되는 것이다.

#### 🙋🏻‍♀️ useState 훅의 결괏값은 어떻게 함수가 실행돼도 그 값을 유지하고 있을까?

리액트는 클로저를 사용해서, 어떤 함수(useState) 내부에 선언된 함수(setState)가 함수의 실행이 종료된 이후에도(useState가 종료된 이후) 지역변수인 state를 계속 참조할 수 있다.

### 실제 useState 내부의 모습을 구현한 모습

```javascript
const MyReact = (function () {
  const global = {};
  let index = 0;

  function useState(initialState) {
    if (!global.states) {
      // 애플리케이션 전체의 states 배열을 초기화한다.
      // 최초 접근이라면 빈 배열로 초기화한다.
      global.states = [];
    }

    // states 정보를 조회해서 현재 상태값이 있는 지 확인하고,
    // 없다면 초깃값으로 설정한다.
    const currentState = global.states[index] || initialState;
    globla.state[index] = currentState;

    const setState = (function () {
      // 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에
      // 접근할 수 있도록 한다.
      let currentIndex = index;
      return function (value) {
        global.states[currentIndex] = value;
        // 렌더링 하는 과정 생략
      };
    })();
    // useState를 쓸 때마다 index를 하나씩 추가한다.
    // index는 setState에서 사용된다.
    // 하나의 state마다 index가 할당돼 있어 그 index가 배열의 값을
    // 가리키고 필요할 때마다 그 값을 가져오게 된다.
    index += 1;

    return [currentState, setState];
  }

  // 실제 useState를 사용하는 컴포넌트
  function Component() {
    const [value, setValue] = useState(0);
  }
})();
```

MyReact의 실행이 끝났음에도 불구하고 useState 함수를 사용할 수 있는 이유는 `클로저`덕분이다. MyReact 클로저 내부에 useState와 관련된 정보를 저장해 두고 이를 필요할 때마다 꺼내 놓는 형식으로 구성돼있다.

useState는 자바스크립트의 특징 중 하나인 클로저에 의존해 구현돼 있을 것이라는 사실을 짐작해볼 수 있다. 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수형 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있다.

---

### 게으른 초기화(lazy initialization)

일반적으로 우리는 useState를 사용하는 경우 인수로 원시값을 넣는 경우가 대다수일 것이다. 하지만, 인수로 특정한 값을 넘기는 함수를 인수로 넣어줄 수도 있다. useState의 인수를 변수가 아닌 함수를 넘겨주는 경우를 게으른 초기화라고 한다. 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다. 만약 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시된다.

만약 useState 인수로 자바스크립트에 많은 비용을 요구하는 작업이 들어가 있다면 이는 계속해서 실행될 위험이 존재할 것이다. 그러나 우려와는 다르게 useState 내부에 함수를 넣으면 이는 최초 렌더링 이후에는 실행되지 않고, 최초의 state 값을 넣을 때만 실행된다.

주로 게으른 초기화는 Storage 접근이나, 고차함수 같은 배열에 대한 접근, 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 사용하는 것이 좋다.

## 3.1.2 useEffect

## 3.1.3 useMemo

## 3.1.4 useCallback

## 3.1.5 useRef

## 3.1.6 useContext

## 3.1.7 useReducer

## 3.1.8 useImperativeHandle

## 3.1.9 useLayoutEffect

## 3.1.10 useDebugValue

## 3.1.11 훅의 규칙
