# 5.2 리액트 훅으로 시작하는 상태 관리

## 5.2.1 가장 기본적인 방법 : useState와 useReducer

useState는 useReducer로 구현됐다. useState나 useReducer 모두 약간의 구현상의 차이만 있을 뿐, 두 훅 모두 지역 상태관리를 위해 만들어졌다.

하지만 훅을 사용할 때마다 컴포넌트별로 초기화되기 때문에 컴포넌트에 따라 서로 다른 상태를 가질 수밖에 없다. -> 전역 상태관리가 아니다.

이렇게 기본적인 useState를 기반으로 한 상태를 지역 상태(local state)라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

### 그렇다면 지역 상태인 변수를 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태로 만들기 위해 어떻게 할 수 있을까?

1. 부모 컴포넌트에서 선언하고 props로 넘겨주기
   - 하지만 props로 제공해야하는 점이 불편할 수 있다.

## 5.2.2 지역 상태의 한계를 벗어나보자 : useState의 상태를 바깥으로 분리하기

useState는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있다는 단점이 있음.

또한 useState로 컴포넌트의 리렌더링을 실행해 최신값을 가져오는 것은 어디까지나 해당 컴포넌트 자체에서만 유효한 전략임.

함수 외부에서 상태를 참조하고 렌더링까지 일어나게 하기 위한 조건

1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링 해야 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트뿐만 아니라 이 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
3. 상태가 원시값이 아닌 객체인 경우는 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다. 예를 들어 {a: 1, b: 2}라는 상태가 있으며 어느 컴포넌트에서 a를 2로 업데이트했다고 가정하자. 이러한 객체 값의 변화가 단순히 b의 값을 참조하는 컴포넌트에서는 리렌더링을 일으켜서는 안된다는 뜻이다.

방법

1. 사용자 정의 훅
2. useSubscription

## useState와 Context를 동시에 사용해보기

5.2.2에서 다룬, 마치 상태 관리 라이브러리처럼 사용하는 예제는 역시 한 가지 단점이 있다. 이 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다는 것이다. 하나의 스토어만 가지면 마치 전역 변수처럼 작동해서 동일한 형태의 스토어를 여러개 가지는 것이 불가능하다.

### 여러 개의 서로 다른 데이터를 공유해 사용하고 싶다면?

1. createStore를 이용해 동일한 타입으로 스토어를 여러개 만들기

   ```typescript
   const store1 = createStore({ count: 0 });
   const store2 = createStore({ count: 0 });
   const store3 = createStore({ count: 0 });
   ```

   이 방법은 해당 스토어가 필요할 때마다 반복적으로 스토어를 생성해야하고, 훅은 스토어에 의존적인 1:1 관계를 맺고 있으므로 스토어를 만들 때마다 해당 스토어에 의존적인 useStore와 같은 훅을 동일한 개수로 생성해야 하기 떄문에 번거롭다. 또한 이 훅이 어느 스토어에서 사용 가능한지 가늠하려면 오직 훅의 이름이나 스토어의 이름에 의지해야 한다.

2. Context와 스토어를 함께 사용하기
   Context를 활용해 해당 스토어를 하위 컴포넌트에 주입한다면 컴포넌트에서는 자신이 주입된 스토어에 대해서만 접근할 수 있게 될 것이다.

   ```typescript
   export const CounterStoreContext = createContext<Store<CounterStore>>(
     createStore<CounterStore>({ count: 0, text: "hello" })
   );

   export const CounterStoreProvider = ({
     initialState,
     children,
   }: PropsWithChildren<{
     initialState: CounterStore;
   }>) => {
     const storeRef = useRef<Store<CounterStore>>();

     if (!storeRef.current) {
       storeRef.current = createStore(initialState);
     }

     return (
       <CounterStoreContext.Provider value={storeRef.current}>
         {children}
       </CounterStoreContext.Provider>
     );
   };
   ```

   CounterStoreProvider로 넘기는 props가 불필요하게 변경되면 리렌더링이 일어나기 때문에 이를 방지하기 위해 useRef를 사용하여 최초 렌더링 시에서만 스토어를 만들어서 값을 내려주는 것으로 만들어졌다.

   내려준 값을 사용하기 위해선 Context에서 제공하는 스토어에 접근해야하기 때문에 useStore나 useStoreSelector 대신에 다른 접근을 시도해야 한다.

   ```typescript
   export const useCounterContextSelector = <State extends unknown>(
     selector: (state: CounterStore) => State
   ) => {
     const store = useContext(CounterStoreContext);
     const subscription = useSubscription(
       useMemo(
         () => ({
           getCurrentValue: () => selector(store.get()),
           subscribe: store.subscribe,
         }),
         [store, selector]
       )
     );
     return [subscription, store.set] as const;
   };
   ```

   위 훅과 Context를 함께 사용하는 예제를 보면, Context와 Provider를 기반으로 각 store값을 격리해서 관리했다.

   장점

   - 스토어를 사용하는 컴포넌트는 해당 상태가 어느 스토어에서 온 상태인지 신경 쓰지 않아도된다.
   - Context와 Provider를 관리하는 부모 컴포넌트의 입장에서는 자신이 자식 컴폰언트에 따라 보여주고 싶은 데이터를 Context로 잘 격리하기만 하면 된다.
