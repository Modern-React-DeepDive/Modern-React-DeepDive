# 5.1 상태관리는 왜 필요한가

웹 개발 시의 상태란 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

웹 어플리케이션에서 상태로 분류될 수 있는 것들

- UI : 다크/라이트 모드, 라디오를 비롯한 각종 Input, 알림창의 노출 여부 등 많은 종류의 상태가 존재
- URL : 브라우저에서 관리하고 있는 상태값. 여기에도 우리가 참고할 만한 상태가 존재할 수 있다. URL parameter 등
- 폼(form) : 로딩 중인지, 현재 제출됐는지, 접근이 불가능한지, 값이 유효한지 등
- 서버에서 가져온 값 : 클라이언트에서 서버로 요청을 통해 가져온 값. API 요청 등

## 5.1.1 리액트 상태 관리의 역사

### Flux 패턴의 등장

---

양방향 데이터 바인딩의 원인으로 뷰가 모델을 변경할 수 있고, 반대의 경우도 변경할 수 있었다. 이는 코드를 작성하는 입장에서는 간단할 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해줄수록 관리가 어려워진다.

이에 페이스북팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 Flux 패턴의 시작이다.

**[Flux의 기본적인 단방향 데이터 흐름]**<br>
Action -> Dispatcher -> Model -> View

`Action`: 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.<br>
`Dispatcher`: 액션을 스토어에 보내는 역할. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.<br>
`Store`: 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 변경할지가 정의되어 있다.<br>
`View`: 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다.

**[useReducer란?]**<br>
state를 생성하고 관리할 수 있게해주는 도구

언제 사용할까?

- 여러 개의 하위값을 포함하는 복잡한 state를 다뤄야할 때 useState대신 useReducer를 사용하면 코드를 훨씬 더 깔끔하게 쓸 수 있다.

작동 방식

- type Action으로 액션이 어떤 종류가 있고 어떤 데이터를 필요로 하는지 정의할 수 있으며 스토어의 역할을 하는 것이 useReducer와 reducer인데, 각각 현재 상태와 상태에 따른 값이 어떻게 변경되는지를 정의할 수 있다. 그리고 dispatcher로 이 액션을 실행하고 이를 뷰인 App에서 보여준다.

리액트는 단방향 데이터 바인딩을 기반으로 한 라이브러리 이기때문에 이러한 단방향 흐름을 정의하는 Flux 패턴과 궁합이 잘맞다. 상태와 그 상태의 변경에 대한 흐름과 방식을 단방향으로 채택한 것이 바로 리액트 기반 Flux의 특징이라고 볼 수 있다.

### 시장 지배자 리덕스의 등장

---

리덕스는 Flux 구조를 구현하고 Elm 아키텍처를 도입했다.

Elm이란 웹페이지를 선언적으로 작성하기 위한 언어다.
Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고, 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력했다.

- 모델(model) : 애플리케이션의 상태
- 뷰(view) : 모델을 표현하는 HTML
- 업데이트(update) : 모델을 수정하는 방식

리덕스는 이 Elm의 영향을 받아 작성되었으며 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다. 이러한 작업은 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.

리덕스는 리액트 생태계에 많은 영향을 미쳤지만, 마냥 편한것은 아니었다. 단순히 하나의 상태를 바꾸고 싶어도 해야 할 일이 너무 많았다. 먼저 어떠한 액션인지 타입을 선언해야 하고, 이 액션을 수행할 creator, 함수를 만들어야 했다. 그리고 dispatcher와 selector도 필요하고, 새로운 상태가 어떻게 기존의 리듀서 내부에서 어떤 식으로 변경돼야 할지, 새로 만들어야 할지 정의가 필요하다.

### Context API와 useContext

---

나오게된계기

- props의 불편함, props의 drilling
- 리덕스로 대체하자니 보일러플레이트 부담

```javascript
...
render() {
	return (
		<CounterContext.Provider value={this.state}>
			<button onClick={this.handleClick}>+</button>
			<DummyParent />
		</CounterContext.Provider>
	)
}
...
// DummyParent 안 CounterComponent에 있는 코드
render() {
	return (
		<CounterContext.Consumer>
			{(state) => <p>{state?.count}</p>}
		</CounterContext.Consumer>
	)
}
```

### 훅의 탄생, 그리고 React Query와 SWR

---

리액트 16.8에서 함수 컴포넌트에서 사용할 수 있는 다양한 훅 API를 추가했는데, 이러한 훅 등장으로 이전에는 볼 수 없던 방식의 상태관리가 등장했다.

- React Query, SWR

두 라이브러리 모두 외부에서 데이터를 불러오는 fetch를 관리하는데 특화된 라이브러리 이지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

### Recoil, Zustand, Jotai, Valtio에 이르기까지

요새 새롭게 떠오르고 있는 많은 상태 관리 라이브러리는 기존의 리덕스 같은 라이브러리와는 차이점이 있는데, 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 것이다. Recoil, Jotai, Zustand, Valtio의 저장소를 방문해보면 모두 peerDependencies로 리액트 16.8버전 이상을 요구하고 있음을 확인할 수 있다. 애초에 리액트와의 연동을 전제로하기에 다른 라이브러리를 설치하지 않아도 된다.

이는 전역 상태관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었고, 훅을 지원함으로써 함수 컴포넌트에서 손쉽게 사용할 수 있다는 장점을 가지고 있다.
