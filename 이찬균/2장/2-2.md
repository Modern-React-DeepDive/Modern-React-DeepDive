# 2-2. 가상 DOM과 리액트 파이버

상태: 2장. 리엑트 핵심 요소

### 들어가면서

리액트의 가상 DOM이 무엇인지, 실제 DOM에 비해 어떤 이점이 있는지 살펴본다.

가상 DOM을 다룰 때 주의할 점을 알아본다.

# 1. DOM과 브라우저 렌더링 과정

DOM : 웹페이지에 대한 이터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

### 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(`DOM`)를 생성
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(`CSSOM`)를 생성
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 모든 노드를 방문하지 않고, 사용자 눈에 보이는 노드만 방문
   `display:none` 과 같이 화면에 보이지 않는 요소는 방문해서 작업하지 않음.
6. 5에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 노드에 적용한다.

<aside>
💡 6에서 DOM 노드에 CSS를 적용하는 과정은 두 가지로 나뉜다. 
`레이아웃` : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정
`페인팅` : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

</aside>

<img width="864" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-08_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 34 26" src="https://github.com/lgyn10/algorithm-lgyn/assets/72643542/6182bca0-f979-4a68-971a-320eac1f7aff">

# 2. 가상 DOM의 탄생 배경

`색상이 변경` → 리페인팅만 일어나서 빠르게 처리

`특정 요소의 노출 여부 변경 or 사이즈 변경 등 요소의 위치 크기 재계산` → 레이아웃이 일어나고, 필연적으로 리페인팅이 일어남 → 더 많은 비용

### SPA에서의 렌더링

- 하나의 페이지에서 계속해서 요소의 위치를 재계산
- 라우팅이 변경되는 경우, 대부분의 요소를 삭제, 삽입, 위치를 계산하는 과정이 이루어진다.
- DOM을 관리하는 과정에서 부담 비용이 크다.

→ 인터랙션에 따른 DOM 변경을 모두 추적하지 않고, DOM의 최종 결과물만 있으면 된다.

### Virtual DOM

- 리액트가 관리하는 가상의 DOM
- 웹 페이지가 표시해야 할 DOM을 일단 메모리에 저장하고, 리액트(`react-dom`)가 실제 변경에 대한 준비가 완료되면 Real DOM에 반영
- DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 거치면, 여러 번 발생할 렌더링 과정 최소화 가능

<aside>
💡 Virtual DOM은 Real DOM을 관리하는 브라우저보다 빠르다는 것은 오해이다.
대부분의 상황에서 웬만한 앱을 만들 수 있을 정도로 충분히 빠르다는 것

</aside>

# 3. 가상 DOM을 위한 아키택처, 리액트 파이버

- 가상 DOM을 만드는 과정을 리액트는 어떻게 처리할까?
- 리액트는 여러 번의 렌더링 과정을 압축해 어떻게 최소한의 렌더링 단위를 만들어 낼까?

## 3-1. 리액트 파이버란?

- 리액트에서 관리하는 JS 객체
- 파이버 재조정자(`fiber-reconciler`)가 관리하며, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 수행한다.

<aside>
💡 재조정(`Reconcilation`) : 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)
`Diffing Algorithm`

</aside>

### 과거 리액트의 조정 알고리즘

- 스택 조정자 (스택 알고리즘 사용)
- 동기적으로 작업
- JS의 특징인 싱글 스레드라는 점으로 인해, 리액트의 비효율성 야기

### 파이버가 하는 작업

1. 작업을 작은 단위로 분할하고 쪼갠 다음, 우선 순위를 매긴다.
2. 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
3. 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

<aside>
💡 렌더링 작업 과정
1. `렌더 단계`에서 리액트는 모든 비동기 작업을 수행. 이 단계에서 앞서 언급한 파이버의 작업인 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다. 그리고 `finishedWork()` 라는 작업으로 마무리
2. `커밋 단계`에서 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업인 `commitWork()`가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

</aside>

### 리액트에 구현된 파이버 코드

- 리액트 요소와 유사하지만, 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다.
- 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적 재사용된다.
- state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점에 실행된다.
- 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다.
- 즉, 이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 가능한 빠르게 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.

```flow
// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.js

function FiberNode(tag, pendingProps, key, mode) {
	// Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;
  this.refCleanup = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  // ... 이하 생략
```

`tag` : 1:1로 연결되는 것은 리액트 컴포넌트, HTML의 DOM 노드 또는 다른 어떤 것일 수 있다.

`stateNode` : 파이버 자체에 대한 참조 정보를 가지고 있고, 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.

`child, sibling, return` : 파이버 간의 관계 개념을 나타내는 속성. children이 없다.

`index` : 여러 sibling 사이에서 자신의 위치가 몇 번째인지 표현

`pendingProps` : 아직 작업을 미처 처리하지 못한 props

`memoizedProps` : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps로 저장해 관리한다.

`updateQueue` : 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐

`memoizedState` : 함수 컴포넌트의 훅 목록이 저장된다.

`alternate` : 리액트 파이버 트리와 이어질 개념. 반대편 트리 파이버를 가리킨다.

<aside>
💡 `스케줄링` : 컴포넌트의 렌더링 및 업데이트 타이밍을 관리하는 방법

</aside>

## 3-2. 리액트 파이버 트리

리액트 내부에는 두 개의 파이버 트리가 존재

1. `current tree` : 현재 모습을 담은 파이버 트리
2. `workInProgress tree` : 작업 중인 상태를 나타내는 파이버 트리

- 현재 존재하는 트리인 `current tree` 를 기준으로 작업이 시작된다.
- 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 `workInProgress tree` 를 빌드하기 시작한다.
- 리액트 파이버의 작업이 끝나면, `더블 버퍼링` 기법으로 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꾼다.
- 더블 버퍼링은 `커밋 단계` 에서 수행된다.

## 3-3. 파이버의 작업 순서

### 파이버 노드의 생성 흐름

1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그 다음 `completeWork()` 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2,3 번이 모두 끝났다면 return 으로 돌아가 자신의 작업이 완료됐음을 알린다.
5. 루트 노드가 완성되는 순간, 최종적으로 `commitWork()`가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다.

이렇게 트리가 생성된다.

### 여기에서 setState로 업데이트가 발생하면?

- 최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.
- 가급적 객체를 새롭게 만들기보다는 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.

# 4. 파이버와 가상 DOM

- 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍쳐 내부에서 비동기로 이뤄진다.
- 실제 브라우제 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많다.
- 따라서 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

<aside>
💡 파이버와 가상 DOM은 동일한 개념은 아니다. 
리액트 네이티브에서도 리액트 파이버를 사용하기 때문이다.

</aside>

# 5. 정리

가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다.
