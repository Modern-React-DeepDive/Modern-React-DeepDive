# 2-5. 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

상태: 2장. 리엑트 핵심 요소

### 들어가면서

`useMemo`, `useCallback` 과 같은 리액트 API와 고차 컴포넌트인 `memo` 는 리액트 렌더링을 최소화하기 위해 제공된다. 

정확히 위의 세 가지 기법은 언제 사용하는 것이 좋을까.

- 렌더링이 자주 일어나는 컴포넌트?
- 렌더링이 자주 일어나는 컴포넌트를 어떻게 알 수 있을까?
- 렌더링이 일어날 것 같은 영역에 모조리 추가할까?
- 의존성 배열이 생략된 `useEffect` 를 모든 컴포넌트에 추가해서 실제로 렌더링이 돌아가는지 확인할까?
- 무거운 연산의 기준은 무엇일까?
- 함수 결과도 다 메모이제이션할까?
- 렌더링 비용과 메모이제이션 비용 중 어떤 게 더 비싼 걸까?

# 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 비용이 드는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다는 주장

→ 대부분의 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

### 메모이제이션의 비용

1. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
2. 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 작업 

위와 같은 `메모이제이션의 비용`이 `리렌더링 비용`보다 저렴한가?

<aside>
💡 섣부른 최적화는 항상 경계해야 한다. 
`premature optimization` `premature memoization`

</aside>

### 왜 모든 컴포넌트를 PureComponent나 memo를 감싸지 않았는가

메모이제이션이 애초에 비용 측면에서 리렌더링 비용보다 저렴하다면 모든 컴포넌트를 PureComponent나 memo로 감싸는 작업을 했을 것이다. 그렇지 않고 이를 개발자에게 선택권을 주었다는 것은 메모이제이션이 모든 문제를 해결하지 못한다는 것을 말한다. 

- 메모이제이션은 항상 트레이드 오프가 있는 기법
- 이전 결과를 캐시로 저장해 미래에 나은 성능을 위해 메모리를 차례대로 점유한다.
- 렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다.
- 즉, 메모이제이션으로 성능 개선이 렌더링보다 낫지 않다면 안하느니만 못하는 상황이다.

일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다. 

<aside>
💡 `PureComponent` 클래스
`shouldComponentUpdate()` 함수를 `얕은 비교` 하도록 설계되었다. 
즉, 얕은 비교를 통해 어떤 데이터가 변경되었을 때만 render() 함수를 호출한다. 
PureComponent는 얕은 비교를 위해서 shallow-equal 라이브러리의 `shallowEqual()` 함수를 사용한다.

</aside>

# 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

## 1. memo

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
- memo를 일단 그냥 다 적용하는 방법

위의 두 가지 선택권이 있을 때, 첫 번째의 경우는 가장 이상적이다. 하지만, 리액트 애플리케이션 규모가 커지고, 컴포넌트의 복잡성이 증가하는 상황애서도 이러한 기조를 유지할 수 있는지 생각해봐야 한다. 

그렇다면 일단 모든 컴포넌트를 memo로 감싼 뒤, 이로 인해 불필요한 비용이 얼마나 드는지 생각해보자. 

### 잘못된 memo로 지불해야 하는 비용

렌더링 비용이 저렴하거나 별로 렌더링이 안 되는 컴포넌트에 memo를 썼을 때 역으로 지불해야 하는 비용을 생각해보자.

그 비용은 `props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용` 이다. 

메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용한다. 여기에서 `이전 렌더링 결과물을 저장` 하는 작업은 리액트의 기본적인 재조정 알고리즘 때문에 어차피 이루어 져야할 작업이다. 따라서 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다. 

### memo를 하지 않았을 때 치러야 할 위험 비용

1. 렌더링을 함으로써 발생하는 비용
2. 컴포넌트 내부의 복잡한 로직의 재실행
3. 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
4. 리액트가 구 트리와 신규 트리를 비교

## 2. useMemo, useCallback

`useMemo와 useCallback을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정`과 이러한 처리 없이 `값과 함수를 매번 재성성하는 비용` 중에서 무엇이 더 저렴한지 매번 계산해야 한다. 

이 또한 마찬가지로 무조건 메모이제이션하는 방법을 먼저 고민해보자.

리렌더링 시, 메모이제이션 적용하지 않은 경우

- 객체는 재생성되어 결과적으로 참조는 달라진다.
- 이 달라진 참조에 대한 값을 어디서든 쓰지 않으면 문제될 것이 없다.
- 하지만, useEffect와 같은 의존성 배열에 쓰이면 어떻게 될까? → 변경된 참조로 인해 다른 쪽에도 영향

```tsx
function useMath(number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return useMemo(() => {
    double, triple;
  }, [double, triple]);
}
```

useMath의 반환값을 useMemo로 감싼다면 값이 변경되지 않은 한 같은 결과물을 가질 수 있고, 그 덕분에 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다. 

즉, 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다. 

- 메모이제이션을 하지 않는 것보다 메모이제이션 했을 때 더 많은 이점이 있다.

# 결론 및 정리

만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 좋다는 것은 두 주장의 공통이다. 

시간적 여유가 있다면 섣부른 메모이제이션을 지양하는 자세를 가지고 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보면서 적용하는 것을 권장한다. 

책의 후반부에서는 실제로 크롬 메모리 프로파일러로 분석하면서 state나 props의 변화에 따라 크롬 내부에서 어떤 일이 일어나는지 확인할 수 있는 방법을 재공한다. 이는 리액트에 대한 이해도와 웹 애플리케이션에 대해 접근하는 관점을 넓히는 좋은 기회가 될 것이다. 

시간적 여유가 없다면, 앞서 리액트 파이버에서의 작동과 흐름을 살펴봐서 알겠지만 일반적으로는 props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다. 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다.