# 2-4. 렌더링은 어떻게 일어나는가?

상태: 2장. 리엑트 핵심 요소

### 들어가면서

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

# 1. 리액트의 렌더링이란?

→ 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 porps와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

# 2. 리액트 렌더링이 일어나는 이유

### 최초 렌더링

→ 사용자가 처음 앱에 진입하면 당연히 렌더링해야 할 결과물이 필요하기에, 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행

### 리렌더링

1. 클래스 컴포넌트의 setState가 실행되는 경우
2. 클래스 컴포넌트의 forceUpdate가 실행되는 경우
3. 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
4. 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
5. 컴포넌트의 key props가 변경되는 경우
6. props가 변경되는 경우, 부모로부터 전달받는 값이므로 자식 컴포넌트에서도 변경이 필요
7. 부모 컴포넌트가 렌더링되는 경우, 자식 컴포넌트도 무조건 리렌더링

<aside>
💡 리액트 배열에서 `key` 값이 중요한 이유
→ 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값
→ current tree와 workInProgress tree 사이에서 같은 컴포넌트인지 구별하는 값이 `key` 
→ `key` 값으로 배열의 인덱스는 권장되지 않는다. 
→ `데이터의 고유한 ID` `해시 함수 사용` `UUID 라이브러리 사용`

</aside>

- `MobX와 Redux` 는 라이브러리 어디에선가 각자의 방법으로 상태를 관리해 주지만 이 상태관리가 리액트 리렌더링으로 이어지지는 않는다.
- `mobx-react, react-redux` 가 앞선 라이브러리로부터 변경된 상태를 바탕으로 리렌더링을 발생시킴
- `Recoil`은 별도의 리액트 패키지가 없이도 상태 관리가 되는 라이브러리로, 내부에서 useState 등을 통해 리렌더링을 발생시킴

# 3. 리액트의 렌더링 프로세스

1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
2. 업데이트가 필요한 컴포넌트를 발견했을 때

   `클래스 컴포넌트의 경우` : 클래스 내부의 `render()` 함수를 실행

   `함수 컴포넌트의 경우` : `FunctionComponent()` 자체를 호출한 뒤, 결과물 저장

```flow
// jsx
function Hello() {
	return (
		<TestComponent a={35} b='yceffort'>
		안녕하세요
		</TestComponent>
	)
}

// js
function Hello() {
	return React.createElement(
		TestComponent,
		{ a: 35, b: 'yceffort' },
		'안녕하세요',
	)
}

// 렌더링 결과물
{type: TestComponent, props : { a: 35, b: 'yceffort', children: '안녕하세요' }}
```

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영한다. → `재조정`

재조정 과정이 끝나면 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

리액트 렌더링은 `렌더 단계` 와 `커밋 단계` 로 분리되어 실행된다.

# 4. 렌더와 커밋

### 렌더 단계

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 일컫는다.
- 즉, 렌더링 프로세스에서 컴포넌트를 실행하여(`render() 또는 return`) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
- 크게 `type` , `props` , `key` 를 비교

### 커밋 단계

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.
- 리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다. 함수 컴포넌트에서는 `useLayoutEffect` 훅을 호출한다.

<aside>
💡 **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.** 
→ 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없는 경우, 즉 변경사항을 계산했는데 변경 사항이 없다면 이 커밋 단계는 생략될 수 있다.
→ 즉, 리액트 렌더링은 가시적인 변경이 일어나지 않아도 발생
→ 렌더 단계에서 변경 사항 감지 못하면 커밋 단계 생략되어 DOM 업데이트 안 일어난다.

</aside>

<img width="656" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8 54 39" src="https://github.com/lgyn10/algorithm-lgyn/assets/72643542/bc18ffe8-9514-485a-9e05-fe706385d17a">

### 동시성 렌더링

- 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링이 리액트 18에서 도입
- 렌더링 중 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나 필요하다면 중단하거나 재시작하거나 경우에 따라 포기할 수도 있다.
- 이를 통해 과거 동기식으로 작동하면서 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있어, 매끄러운 사용자 경험을 제공한다.

# 5. 일반적인 렌더링 시나리오

```flow
import { useState } from 'react';

export default function A() {
  return (
    <div className='App'>
      <h1>Hello React!</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setCounter] = useState(0);

  function handleButtonClick() {
    setCounter((prev) => prev + 1);
  }
  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

function C({ number }) {
  return (
    <div>
      {number}
      <D />
    </div>
  );
}

// ver 1. 일반
function D() {
  return <>리엑트 재밌다!</>;
}

// ver 2. memo 적용
const D = memo(() => {
  return <>리액트 재밌다!</>;
});
```

1. B 컴포넌트의 setState가 호출된다.
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 렌더링 경로를 검사한다.
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
5. 하위 컴포넌트인 B 컴포넌트는 업데이트가 필요하다고 체크돼 있으므로 B를 리렌더링한다.
6. 5과정에서 B는 C를 반환했다.
7. C는 props인 number가 업데이트됐다. 그러므로 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트한다.
8. 7과정에서 C는 D를 반환헀다.
9. D는 업데이트가 필요한 컴포넌트로 체크되어 있지 않지만, C가 렌더링됐으므로 그 자식인 D도 렌더링됐다.

<aside>
💡 D 컴포넌트에 memo를 추가한 ver 2
→ B 컴포넌트 상태값이 변경됐어도 memo로 래핑돼 있어 렌더링이 일어나지 않음
→ 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋단계도 생략

<img width="637" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9 24 40" src="https://github.com/lgyn10/algorithm-lgyn/assets/72643542/d76a4ec6-fe67-4477-bbb1-2a1d28e5d288">

</aside>

# 6. 정리

- state나 props 등의 변화가 리액트 애플리케이션 전반에 어떠한 영향을 미치는지 살펴봐야 한다.
- 리액트 렌더링 시나리오를 정확히 이해하면 컴포넌트의 트리 구조를 개선하거나 불필요한 렌더링 횟수를 줄여 성능을 높일 수 있다.
