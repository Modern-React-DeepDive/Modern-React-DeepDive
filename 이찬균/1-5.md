# 1-5. 이벤트 루프와 비동기 통신의 이해

상태: 1장. 리액트 개발를 위한 JS

### 들어가면서

---

자바스크립트는 싱글 스레드에서 작동한다. 즉, 한번에 하나의 작업만 동기 방식으로만 처리할 수 있다. 그러나 이러한 싱글 스레드 기반의 자바스크립트에서도 많은 양의 비동기 작업이 이루어지고 있다.

과거 렌더링 스택을 비우는 방식으로 구현됐던 동기식의 렌더링이 16 버전에 접어들면서 비동기식으로 작동하는 방법도 소개되었다. 이처럼 리액트에서도 비동기식으로 작동하는 작업이 존재한다.

자바스크립트 환경에서 이러한 것이 어떻게 가능한지 알기 위해서는 이러한 비동기 작업이 어떻게 처리되는지 이해하고 비동기 처리를 도와주는 이벤트 루프를 비롯한 다양한 개념에 대해 알고 있어야 한다.

비동기 코드의 작동 방식에 대해 이해한다면

- 자바스크립트에서 어떻게 여러 가지 요청을 동시에 처리하고 있는지,
- 이러한 요청받은 테스크에 대한 우선 순위는 무엇인지,
- 주의할 점은 무엇인지

파악하여 사용자에게 더욱 매끄러운 서비스를 제공할 수 있을 것이다.

# 1. 싱글 스레드 자바스크립트

하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다.

### 그렇다면 JS는 왜 싱글 스레드로 설계됐을까?

- 멀티 스레드의 단점: 동시성 문제
- JS의 탄생 배경 : 단순한 목적을 위한 언어

### 싱글 스레드라는 것은 무엇을 의미할까?

- 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것을 의미
- 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다는 것을 의미
- Run-to-completion을 특징으로 한다.

<aside>
📌 Node.js에서 새롭게 추가된 `Worker` 나 브라우저에서 제공하는 `WebWorker`를 활용하면 동시에 여러 작업을 처리할 수 있지만, 두 기능은 매우 최근에 나왔기 때문에 본 절에서 논외로 한다.

</aside>

자바스크립트의 비동기 코드 처리를 이해하기 위해서는 `이벤트 루프 개념을 이해`해야 한다.

# 2. 이벤트 루프

자바스크립트 런타임 중에서 가장 유명한 V8을 기준으로 한다.

- 이벤트 루프는 ECMAScript, 즉 JS 표준에 나와 있는 내용은 아니다. 즉, 이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라고 볼 수 있다.

## 2-1. 호출 스택과 이벤트 루프

`호출 스택` : 자바스크립트에서 수행해야 할 코드나 함수를 순차적적으로 담아두는 스택

이 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프다.

`이벤트 루프` : 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할

이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.

`코드를 실행하는 것` 과 `호출 스택이 비어있는지 확인하는 것` 모두가 단일 스레드에서 일어난다.

즉, 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어난다.

### 비동기 작업의 실행

```tsx
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('foo');
  setTimeout(bar, 0);
  baz();
}

foo();
```

1. `foo()` 가 호출 스택에 먼저 들어간다.
2. `foo()` 내부에 console.log가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 `foo()` 는 존재)
4. `setTimeout(bar(),0)` 이 호출 스택에 들어간다.
5. 4번에 대해 타이머 이벤트가 실행되며 **태스크 큐로 들어가고, 그 대신 바로 스택에서 제거**된다.
6. `baz()` 가 호출 스택에 들어간다.
7. `baz()` 내부에 console.log가 존재하므로 호출 스택에 들어간다.
8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 `foo(), baz()`는 존재)
9. 더 이상 `baz()` 에 남은 것이 없으므로 호출 스택에서 제거된다 (아직 `foo()` 는 존재)
10. 더 이상 `foo()` 에 남은 것이 없으므로 호출 스택에서 제거된다.
11. 이제 호출 스택이 완전히 비워졌다.
12. **이벤트 루프가 호출 스택이 비워져 있다는 것을 확인했다. 그리고 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 `bar()` 를 호출 스택에 들여보낸다.**
13. `bar()` 내부에 console.log가 존재하므로 호출 스택에 들어간다.
14. 13의 실행이 끝나고, 다음 코드로 넘어간다. (아직 `foo()` 는 존재)
15. 더 이상 `bar()` 에 남은 것이 없으므로 호출 스택에서 제거된다.

<aside>
📌 비동기 함수는 누가 수행하는가? 
`n초 뒤에 setTimeout을 요청하는 작업은 누가 처리할까?` 
`fetch를 기반으로 실행되는 네트워크 요청은 누가 보내고 응답을 받을 것인가?`

→ 이러한 작업들은 JS 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다.
→ 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저나 Node.js의 역할이다.
→ 즉, JS 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 web API 등은 모두 JS 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다.

</aside>

# 3. 태스크 큐와 마이크로 태스크 큐

## 3-1. 태스크 큐

`setTimeout` `setInterval` `setImmediate`

- 태스크 큐란 실행해야 할 태스크의 집합을 의미
- 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다.
- 태스크 큐는 자료구조의 큐가 아니고 set 형태를 띈다.
  → 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다.
- 태스크 큐에서 의미하는 `실행해야 할 테스크` 라는 것은 비동기 함수의 콜백함수나 이벤트 핸들러 등을 의미한다.
- 즉, 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 것이다.

## 3-2. 마이크로 태스크 큐

`process.nextTick` `Promises` `queueMicroTask` `MutationObserver`

- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖는다.
- 대표적으로 `Promise` 처리이며, 기존 태스크 큐보다 우선권을 갖는다.
- 즉, setTimeout과 setInterval은 Promise보다 늦게 실행된다.
- 명세에 따르면 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다.

### 렌더링 시점

- 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다.
- 각 마이크로 테스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.

```tsx
// 동기 코드
console.log('a');

// 태스크 큐 코드
setTimeout(() => console.log('b'), 0);

// 마이크로 태스크 큐 코드
Promise.resolve().then(() => console.log('c'));

// 브라우저가 다음 리페인트 전에 콜백함수을 호출 하는 함수
window.requestAnimationFrame(() => console.log('d'));
```

`크롬`

<img width="471" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12 41 55" src="https://github.com/lgyn10/lgyn10/assets/72643542/4d3269c8-9777-417d-8957-9c18f485bc4b">

`사파리`

<img width="516" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12 52 33" src="https://github.com/lgyn10/lgyn10/assets/72643542/3df722fd-1fc0-4646-9c24-43c2bf2078d3">

위에서 `1` 이라는 숫자를 통해서 렌더링 시점을 파악할 수 있다.

<aside>
❓ 책에서는 **a → c → d → b** 순으로 출력된다고 했다. 
하지만, 
`크롬`은 **a → c → 1 → b → d** 순으로 출력
`사파리` 는 **a → c → 1 → b** 순으로 출력
`1` 이 requestAnimationFrame()가 실행된 시점으로 이해해야하나..?

</aside>

# 4. 정리

- 자바스크립트 코드를 실행하는 것 자체는 싱글 스레드로 이루어져서 비동기 처리하기 어렵다.
- JS 실행 이외의 `태스크 큐`, `이벤트 루프`, `마이크로 태스크 큐`, `브라우저/Node.js API` 등이 적정한 생태계를 이루고 있기 때문에 싱글 스레드로는 불가능한 비동기 이벤트 처리가 가능해진 것이다.
