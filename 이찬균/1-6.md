# 1-6. 리액트에서 사용하는 JS 문법

상태: 1장. 리액트 개발를 위한 JS

### 들어가면서

---

브라우저마다 지원하는 자바스크립트 문법의 상한선이 존재한다.

이러한 사용자의 다향한 브라우저 환경, 그리고 최신 문법을 작성하고 싶은 개발자의 요구를 해결하기 위해 탄생한 것이 `Babel` 이다.

`Babel` 은 JS의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일한다.

`Babel` 이 어떻게 최신 코드를 트랜스파일하는지, 그리고 그 결과 어떤 코드가 생성되는지 이해하면 향후 애플리케이션을 디버깅하는 데 도움이 된다.

# 1. 구조 분해 할당

- 배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것을 의미
- 객체나 배열에서 선언문 없이 즉시 분해해 변수를 선언하고 할당하고 싶을 때 사용
- 배열 → ES6, 객체 → ECMA 2018

## 1-1. 배열 구조 분해 할당

`useState` 가 배열을 반환하는 이유는, 객체 구조 분해 할당은 사용하는 쪽에서 원하는 이름으로 변경하는 것이 번거롭기 때문이다.

1. 배열의 구조분해 할당은 `,` 위치에 따라 값이 결정된다. 중간 인덱스에 대한 할당을 생략하고 싶다면 다음과 같이 선언 가능하다.

```tsx
const arr = [1, 2, 3, 4];
const [one, , , four] = arr; // 2,3 은 아무런 표현식이 없으므로 변수 할당이 생략된다.
```

1. 사용하고자 하는 배열의 값이 없는 경우에는 `undefined` 기본값을 사용한다.

```tsx
const arr = [1, 2, 3];
const [, , , , , one] = arr;
console.log(one); // undefined
```

1. 배열 구조분해할당에는 기본값을 선언할 수도 있다.

```tsx
const arr = [1, 2];
const [a = 10, b = 10, c = 10] = arr;
// a 1
// b 2
// c 10

// 주의할 점은 undefined일 때만 기본값을 사용한다는 것
const [a = 1, b = 1, c = 1, d = 1, e = 1] = [undefined, null, 0, ''];
// a - 1
// b - null
// c - 0
// d - ''
// e - 1
```

- 위에서 a는 명시적으로 undefined가 지정되었고, e의 경우는 배열의 길이를 넘어서서 구조분해할당됐으므로 undefined로 평가되어 기본값이 할당된다.

1. 특정값 이후의 값을 다시금 배열로 선언할 때는 스프레드 연산자를 사용한다.
   이 연산자는 `뒤쪽에서만 사용 가능`하다.

```tsx
const arr = [1, 2, 3, 4, 5];
const [one, ...rest] = arr;
// rest [2,3,4,5]
```

## 1-2. 객체 구조 분해 할당

1. 객체 구조 분해 할당은 객체 내부 이름으로 꺼내온다는 차이가 있다.

```tsx
const object = { a: 1, b: 2, c: 3, d: 4, e: 5 };
const { a, b, c, ...objectRest } = object;
// a-1, b-2, c-3, objectRest-{d: 4, e: 5}
```

1. 새로운 이름으로 다시 할당하는 것 또한 가능하다.

```tsx
const object = { a: 1, b: 2 };
const { a: first, b: second } = object;
// first-1, second-2
```

1. 배열과 마찬가지로 기본값을 주는 것도 가능하다.

```tsx
const object = { a: 1, b: 2 };
const { a = 10, b = 10, c = 10 } = object;
// a 1, b 2, c 10
```

1. 단순히 값으로 꺼내오는 것뿐만 아니라 변수에 있는 값으로 꺼내오는 이른바 계산된 속성 이름 방식도 가능

```tsx
const key = 'a';
const object = {a:1, b:1};

const { [key]: a } = object;\
// a 1
// 계산된 속성 이름을 사용하려면 반드시 이름을 선언하는 :a 와 같은 변수 네이밍이 필요하다.
// 계산된 이름인 [key]로 값을 꺼내기만 했을 뿐, 어느 변수명으로 할당해야 할지 알 수 없기 때문
```

1. 전개 연산자 `. . .` 를 통해 나머지 값을 모두 가져올 수 있다.
   배열과 마찬가지로 전개 연산자는 순서가 중요

### Babel이 객체 구조 분해 할당 처리하는 과정

객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에 만약 자신이 웹 애플리케이션 개발 환경이 ES5를 고려해야 하고, 또 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 써야 하는지 검토가 필요하다.

만약 이러한 트랜스파일은 부담스럽지만, 객체 구조 분해 할당을 통한 `...rest` 와 같은 함수가 필요하다면 `lodash.omit` 을 고려하자.

# 2. 전개 구문

- 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개하여 간결하게 사용할 수 있는 구문이다.
- 배열 → ES6, 객체 → ECMA2018

## 2-1. 배열의 전개 구문

1. 배열간 합성을 `push(), concat(), splice()` 를 쓰지 않고 수행할 수 있다.

```tsx
const arr1 = ['a', 'b'];
const arr2 = [...arr1, 'c', 'd', 'e']; // ['a', 'b', 'c', 'd', 'e']
```

1. 얕은 복사도 수행할 수 있다.

```tsx
const arr1 = ['a', 'b'];
const arr2 = [...arr1];
arr1 === arr2; // false
```

## 2-2. 객체의 전개 구문

객체 전개 구문에서는 순서가 중요하다. 이외는 배열의 경우와 같다.

- 전개 구문 이후에 값 할당이 있다면, 전개 구문이 이전에 전개했던 구문 값을을 덮어쓴다.
- 반대의 경우에는 오히려 전개 구문이 해당 값을 덮어쓰는 일이 생긴다.

# 3. 객체 초기자

- 객체 초기자(`object shorthand assignment`)는 ES6에 도입되었다.
- 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```tsx
const a = 1;
const b = 2;
const obj = { a, b }; // -> {a:a, b:b} 과정을 한 번 거친다고 이해하면 편하다.
// {a: 1, b: 2}
```

# 4. Array 프로토타입의 메서드

## 4-1. Array.prototype.map

## 4-2. Array.prototype.filter

## 4-3. Array.prototype.reduce

- `reduce` 메서드는 콜백함수와 함께 초깃값을 추가로 인수를 받는다.
- 초깃값에 따라 `배열이나 객체 또는 그 이외의 다른 무언가를 반환`할 수 있는 메서드이다.
- `reducer` 콜백 함수를 실행하고, 초깃값에 누적해 결과를 반환한다.

### filter, map의 조합과 reduce 사용 비교

```tsx
// 짝수만 100을 곱해 반환하는 함수의 예제
const arr = [1, 2, 3, 4, 5];

//[200, 400]
const result1 = arr.filter((v) => v % 2 === 0).map((v) => v * 100);
// 배열 2회 순회

const result2 = arr.reduce((acc, cur) => {
  if (cur % 2 === 0) acc.push(cur * 100);
  return acc;
}, []);
// 배열 1회 순회
```

## 4-4. Array.prototype.forEach

- `forEach` 의 반환값은 `undefined` 이다.
- `break, resturn` 등 무엇을 이용해도 배열 순회를 멈출 수 없다. `O(n)`

# 5. 삼항 조건 연산자

- 중첩 삼항 조건 연산자는 피하자.

### 삼항 연산자 적용 전, 리액트 코드

```tsx
import { useState } from 'react';

export default function App() {
  const [color, setColor] = useState('');
  return (
    <div>
      {(() => {
        if (color === 'red') return '빨간색 맞음';
        else return '빨간색 아님';
      })()}
      {/** IIFE */}
    </div>
  );
}
```

### 삼항 연산자 적용 후, 리액트 코드

```tsx
import { useState } from 'react';

export default function App() {
  const [color, setColor] = useState('');
  return <div>{color === 'red' ? '빨간색 맞음' : '빨간색 아님'}</div>;
}
```

# 6. 정리

이러한 최신 문법을 리액트에 반영하기로 마음먹었다면, 이러한 코드를 사용할 준바는 돼 있는지, 즉 바벨과 같은 도구를 이용한 트랜스파일을 지원하는지, 혹은 사용자의 디바이스에서 별도 조치 없이 사용 가능한지를 꾸준히 점검한다면 안정적인 리액트 앱을 만들 수 있겠다.
