## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

### 2.3.1 클래스형 컴포넌트

- constructor()
- props
- state
- 메서드
- 클래스형 컴포넌트의 생명주기 메서드

    - 마운트: 컴포넌트가 생성되는 시점

    - 업데이트: 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점

    - 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점

    - render(): 마운트와 업데이트 과정에서 일어난다. 이 함수는 항상 순수해야 하며 부수 효과가 없어야 한다.
    - componentDidMount(): setState로 state 변경이 가능하지만 생성자에서 할 수 없는 것, API 호출 후 업데이터, DOM에 의존적인 작업(이벤트 리스너 추가) 등을 하는 작업 이외에 남용하지 말 것.
    - componentDidUpdate(): setState로 state 변경이 가능하지만 적절한 조건문을 통해 성능 이슈가 발생하지 않도록 할 것.
    - componentWillUnMount(): setState를 호출할 수 없다. API 호출을 취소하거나 setInterval, setTimeout 타이머를 지우는 작업에 유용
    - shouldComponentUpdate(): state나 Props의 변경으로 리렌더링 되는 것을 막고 싶다면 이 메서드를 사용하면 된다.
    - static getDerivedStateFromProps(): render()를 호출하기 직전에 호출되며 여기서 반환하는 객체는 state로 들어간다.
    - getSnapShotBeforeUpdate(): DOM이 업데이트되기 직전에 호출되어 componentDidUpdate로 반환값이 전달된다. DOM에 렌더링 되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 작업에 유용
    - getDerivedStateFromError(): 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드.
    - componentDidCatch(): 자식 컴포넌트에서 에러가 발생했을 때 실행, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행
- 클래스형 컴포넌트의 한계
    - 데이터 흐름을 추적하기 어렵다. 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있기 때문
    - 애플리케이션 내부 로직의 재사용이 어렵다.
    - 기능이 많아질수록 컴포넌트의 크기가 커진다.
    - 클래스는 함수에 비해 상대적으로 어렵다.
    - 코드 최종 번들 크기를 최적화하기 어렵다.
    - 핫 리로딩(애플리케이션을 실행한 채로 코드의 수정 내용이 바로바로 반영되는 것)을 하는데 상대적으로 불리하다.

### 2.3.2 함수형 컴포넌트

### 2.3.3 함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기 메서드의 부재
    - 함수형 컴포넌트는 useEffect 를 활용해서 생명주기 메서드를 비슷하게 구현할 수 있다.
- 함수형 컴포넌트와 렌더링된 값
    - 함수형 컴포넌트는 렌더링이 일어날 때 마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경된다면 다시 한번 그 값을 기준으로 함수가 호출된다. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.
