**useMemo**와 **useCallback**

→ React Hooks의 일부로, 성능 최적화를 위해 사용된다.

React Hooks는 함수형 컴포넌트 내에서 상태를 관리하고, 생명주기 메서드를 대체하며, 컴포넌트 간 상태 공유 및 재사용을 간편하게 해준다.

- **useMemo : 계산 비용이 높은 함수의 결과 값을 기억하고, 의존성이 변경되지 않는 한 재사용 가능하다.**
- **useCallback : 메모제이션된 콜백 함수를 반환하여 성능을 최적화 한다.**

<br/>

## 🙋‍♀️[2.5.1] 주장 1: 섣부른 최적화는 독이다. 필요한 곳에만 메모이제이션을 추가하자.

메모제이션은 함수의 실행 결과를 저장하여 같은 인수를 갖는 다음 호출 시에 미리 계산된 값을 반환하는 기법이다.

이 기법은 함수의 실행 비용이 높은 경우에 사용되며, 중복된 계산을 방지하여 성능을 향상 시킨다.

주장 1은 메모제이션도 비용이 드는 작업이므로 최적화에 신중해야 한다는 입장이다.

```jsx
function sum(a, b) {
  return a + b
}
```

위와 같이 매우 간단한 수행을 하는 함수가 있다.

- 이 결과도 메모제이션 하는 것이 좋을까?
- 새로운 계산을 하는 것이 좋을까?

`sum**(1,1)`\*\* 을 저장해두고, 해당 함수가 다시 실행될 때 메모리에서 그 값을 꺼내오는 것이 나을까?

자바스크립트 코드에서 `1+1`을 실행하는 것이 나을까?

⇒ 위의 예제는 매우 극단적인 예지만, 대부분의 가벼운 작업은 어딘 가에 메모제이션 하는 것보다 그때그때 계산하는 것이 빠를 수도 있다.

**메모제이션도 두 가지 비용이 있다.**

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전에 결과물을 저장해 두었다가 다시 꺼내오는 작업

⇒ 과연 이 비용이 리렌더링 비용보다 저렴할까.?

그건 상황마다 다를 것이며 신중하게 접근해야 한다.

따라서 섣부른 최적화(premature optimization or premature memoization)는 금물이다.

만약, 이러한 비교와 렌더링이 문제가 되었다면, 리액트에선 진작에 모든 컴포넌트를 PureComponet로 만들거나, memo로 감싸두는 작업을 했을 것,

개발자에게 선택권을 준 것은 메모제이션이 만능이 아니라는 것의 방증이다.

<br/>
  
**리액트 개발자 댄 아브라모프의 트윗**
  
아무 데서나 PureComonent를 쓰지 마세요.
<br/>
⇒ PureComponent사용에 대한 주의

왜모든 컴포넌트에 memo()를 기본값으로 사용하지 않나요? 그게 더 빠르지 않나요?
스스로에게 물어보세요.
<br/>
⇒ memo() 사용 고려, 실제로는 성능 향상을 가져오지 않을 수도…

왜 ladash의 모든 함수에 memoize()를 사용하지 않나요? 그게 더 빠르지 않나요?
혹시 벤치마크로 성능을 확인해봐야 하지 않을까요?
<br/>
⇒ 모든 함수에 memoize()를 적용하는 것이 항상 빠르지는 않다. 어떤 상황에선 오버헤드가 발생할 수도 있다.


리액트 공식 문서에서도 미래의 어떤 경우에 따라서 캐시가 무효화 되는 경우도 있을 것이라고 얘기하고 있다. 따라서 리액트 메모제이션을활용한 최적화는 신중을 기해야한다.

<br/>

## 🙋‍♂️[2.5.2] 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모제이션해 버리자.

섣부른 최적화의 옳고, 그름을 애기 하기 전에 두 가지 주장에서 공통으로 깔고가는 전제는 다음과 같다.

- **일부 컴포넌트에서는 메모제이션 하는 것이 성능에 도움이 된다.**

섣부른 최적화의 여부와 관계 없이, 해당 컴포넌트의 렌더링이 자주 일어나며, 렌더링 사이 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트를 많이 가지고 있다면

memo나 다른 메모제이션 방법을 사용하는 것이 이점이 있을 때가 있다.

그렇다면… 우리에겐 두 가지 선택권이 있다.

1. memo를 컴포넌트의 사용에 따라 잘 살펴보고 **“일부에만”** 적용하는 것
2. memo를 일단 그냥 “**다**” 적용하는 법

1번의 경우 정말 이상적인 상황이다.

그러나, 리액트 애플리케이션의 규모가 커지고, 개발자가 많아지고, 컴포넌트의 복잡성이 증가하는 상황에서도 전자의 기조를 유지할 수 있을까?

일단 memo로 감싼 뒤 생각해보는 건 어떨까?

감싸는 것이 괜찮은지 생각해 보려면 잘못된 컴포넌트의 최적화, 즉 렌더링 비용이 저렴하거나 사실 별로 렌더링이 안될 때 지불해야 하는 비용에 대해 역으로 생각해보자.

<br/>

**잘못된 memo로 지불해야하는 비용**

- props에 대한 얕은 비교가 발생하며 지불해야 하는 비용

⇒ 메모제이션을 위해 cpu와 메모리를 사용해 이전 렌더링 결과를 저장해놓고, 리렌더링 할 필요가 없다면 이전 결과물을 사용해야 한다.

리액트도 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해둬야 한다.

이것이 기본적인 리액트의 재조정 알고리즘이기 때문이다.

즉, 어차피 리액트이 기본적인 알고리즘 때문에 이전 결과물을 저장해두고 있으니, memo로 지불해야 하는 비용은 props의 얕은 비교 뿐이다.

이 비용 또한 props가 크고 복잡해진다면 무시할 수 없지만…

<br/>

**반면, memo를 하지 않았을 때 지불해야 하는 비용**

- 렌더링할 때 발생 비용
- 컴포넌트 내부의 복잡한 로직 재실행
- 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

\* 구 트리 : 이전에 렌더링된 UI 상태를 나타내는 트리 구조_

\* 신규 트리 : 현재 렌더링되어야 할 UI 상태를 나타내는 트리 구조_

얼핏 살펴보아도 memo를 사용하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다.

⇒ 메모제이션은 컴포넌트 자신의 리렌더링 뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 준다..

즉, 메모제이션 하지 않은 것보다 했을 때 더 많은 이점을 누릴 수 있고,

섣부른 초기화라 해도 누릴 수 있는 이점과 이를 실수로 빠트렸을 때 치러야 할 위험 비용 크기 때문에 확신이 없다면 가능한 모든곳에 메모제이션을 활용한 최적화를 하는 것이 좋다.

<br/>

## 💬[2.5.3] 결론 및 정리

두 의견 모두 메모제이션은 리액트 애플리케이션에서 할 수 있는 성능 최적화라는 것에 이견이 없다.

정리를 해보자면,

- 리액트를 배우고 있거나, 리액트를 깊이 이해하고 싶고 시간 투자가 가능한 사람

⇒ 1번 추천 : 섣부른 메모제이션을 지양하며, 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모제이션 해보기..

- 현업에서 리액트를 사용하고 있거나, 실제로 다룰 예정이지만 시간이 없는 사람

⇒ 2번 추천 : 일반적으론 props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.

로직이 조금이라도 들어간 컴포넌트에는 메모제이션이 성능 향상에 도움을 줄 가능성이 크다.
