# [1.2]함수

## ❎ 1.2.1 함수란?

---

자바스크립트에서 함수는 작업을 수행하거나 값을 계산하는 등의 과정을 표현한다.

**함수의 기본 형태**

```jsx
function sum(a, b) {
  return a + b
}

sum(10, 20) //30
```

function으로 시작해 }로 끝나는 부분까지가 함수를 정의한 부분이다.

function 뒤에 오는 것이 함수명,

함수의 입력값으로 받는 a,b를 각각 매개변수라 하며,

return으로 작성된 것이 반환값이다.

그리고 함수의 이름을 사용해 함수를 호출하는데 sum뒤에 넘겨준 10과 20을 인수라고 한다.

리액트에서 컴포넌트를 만드는 함수도 이러한 기초 형태를 띈다.

```jsx
function Component(props) {
  return <div>{props.hello}</div>
}
```
<br/>

## 4️⃣ 1.2.2 함수를 정의하는 4가지 방법

---

### 함수 선언문

자바스크립트에서 함수를 선언할 때 사용하는 가장 일반적인 방식이다.

```jsx
function add(a, b) {
  return a + b
}
```

위의 함수 선언문은 어떠한 값도 표현되지 않았음으로 표현식이 아닌 일반문으로 분류된다.

```jsx
const sum = function (a, b) {
  return a + b
}

sum(10, 24) //34
```

위의 에제는 sum변수에 힘수 sum을 할당하는 , 표현식과 같은 작동을 보였다.

그 이유는, 자바스크립트의 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.

따라서, 함수 선언문은 코드 문맥에 따라 선언문과 표현식으로 사용될 수 있다.

### 함수 표현식

**일급객체란?**

다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체이다.

자바스크립트에서 함수는 일급 객체이다.

함수는 다른 함수의 매개변수가 될 수 있고, 반환값이 될 수 있으며, 할당도 가능하다.

함수가 일급 객체이면 함수를 변수에 할당하는 것이 당연하다.

```jsx
const sum = function add(a, b) {
  return a + b
}
```

함수 표현식에서 할당하려는 함수의 이름을 생략하는 것이 일반적이다. ⇒ 혼란 방지를 위해..

<aside>
💡 **함수 표현식과 선언 식의 차이 ⇒ ”호이스팅”**
함수의 호이스팅은 함수 선언문이 마치 코드 맨 앞 단에 작성된 것처럼 작동하는 자바스크립트의 특징이다. 
함수 선언문은 호이스팅 덕분에 미리 메모리에 등록되고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된다.

반면 함수 표현식은 함수를 변수에 할당한다.
변수에도 호이스팅이 발생하지만, 함수의 호이스팅과 다르게 호이스팅 되는 시점에서 var의 경우 undefined로 초기화 한다는 차이가 있다.

</aside>

### Function 생성자

```jsx
const add = new Function('a', 'b', 'return a + b')
add(10, 24)
```

매개변수와 함수의 몸통을 모두 문자열로 작성한다.

별로 권장되지 않는 방법이다…

### 화살표 함수

```jsx
const add = (a, b) => {
  return a + b
}

const add = (a, b) => a + b
```

ES6에서 새롭게 추가된 함수 생성 방식이다.

function 대신 = > 를 사용해서 함수를 만든다.

<aside>
💡 **화살표 함수와 일반 함수의 차이점**

- constructor를 사용할 수 없다.
- arguments가 존재하지 않는다.
- 가장 큰 차이점은 this 바인딩!

**this란?**

자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.

this는 화살표 함수 이전까지 함수가 어떻게 호출되냐에 따라 동적으로 결정됐다.

하지만, 화살표 함수는 함수 자체의 바인딩을 갖지 않는다.

화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따른다.

</aside>

<br/>

## 🔍 1.2.3 다양한 함수 살펴보기

---

### 즉시 실행 함수(Immediately-invoked function expression)

```jsx
;(function (a, b) {
  return a + b
})(
  10,
  24
)(
  //34

  (a, b) => {
    return a + b
  }
)(10, 24) //34
```

함수를 정의하고, 그 순간 즉시 실행되는 함수를 의미한다.

단 한 번만 호출되고, 다시금 호출할 수 없기 때문에 이름을 붙이지 않는다.

이러한 즉시 실행을 활용하면 독립적인 함수 스코프를 운용할 수 있다.

### 고차함수

자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과를 새로운 함수로 반환시킬 수 있다. 이러한 역할을 고차함수라 한다.

```jsx
const doubledArray = [1, 2, 3].map((item) => item * 2)

doubledArray //[2, 4, 6]

//함수를 반환하는 고차함수의 예
const add = function (a) {
  //a가 존재하는 클로저 생성
  return function (b) {
    //b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a + b
  }
}

add(1)(3) //4
```

<br/>

## 🚫 1.2.4 함수 만들 때 주의 사항

---

### 함수의 부수 효과 억제

부수 효과 (side-effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것.

순수 함수 : 부수 효과가 없는 함수

→언제 어디서 실행해도 같은 결과 값을 반환하여 안정적이라는 장점이 있다.

비순수 함수 : 부수 효과가 존재하는 함수

부수 효과는 웹 개발에서 피할 수 없는 요소이다.

ex. 컴포넌트 내부에서 api호출 , console.log()

→ 리액트 관점에선 useEffect르 ㄹ최소화 하는 것을 부수 효과를 억제하는 것.

### 가능한 작게

하나의 함수에 너무나 많은 일을 하지 않게 하자.

### 이해하기 쉬운 이름

가능한 한 함수 이름은 간결하고 이해하기 쉽게!
