# [5.2] 리액트 훅으로 시작하는 상태 관리

## [5.2.1] useState와 useReducer : 지역 상태 관리

- useCounter훅을 만들어서 함수 컴포넌트 어디서든 사용 가능하게 구현한 사례

```jsx
function useCounter(initCount = 0) {
  const [counter, setCounter] = useState(initCount)

  function inc() {
    setCounter((prev) => prev + 1)
  }
  /*외부에서 받은 숫자나 0을 초깃값으로 상태를 관리하며, 
 inc를 선언해 숫자를 1씩 증가할 수 있도록 구현했다.*/

  return { counter, inc }
}
```

⇒ useCounter를 사용하는 함수 컴포넌트는 이 훅을 사용해 각자의 counter변수를 관리하며

중복되는 로직 없이 숫자 1을 증가시킬 수 있다.

이처럼, 리액트 훅을 기반으로 만든 사용자 정의 훅은 함수 컴포넌트 어디서든 쉽게 재사용 가능하다.

- useReducer또한 지역 상태를 관리할 수 있는 훅이다.

\*useState는 useReducer로 구현됨

useState와 useReducer가 모든 상태 관리의 필요를 해결해줄까? ⇒ no !

❗useState와 useReducer 기반의 사용자 지정 훅의 한계는 명확하다.

: 훅을 사용할 때 마다 컴포넌트별로 초기화되어 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.

(컴포넌트 상태의 파편화)

이렇게 기본적인 useState를 기반으로 한 상태를 지역 상태라고 하며,

이 지역 상태는 해당 컴포넌트에서만 유효하다는 한계가 있다.

❓지역 상태 ⇒ 전역 상태로 만들어 컴포넌트가사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면?

## [5.2.2] 지역 상태 한계 벗어나기 : useState상태 바깥으로 분리하기

- **useState의 한계**
  useState는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되어
  해당 컴포넌트만 사용 가능하다는 단점이 있다.

만약, 어디에선가 해당 값을 업데이트하면 그 값을 참조하고 있는 컴포넌트나 훅에서도 업데이트 된 값을 사용할 수 있지 않을까?

⇒ 리액트에선 작동하지 않는다.

컴포넌트가 리렌더링 되지 않는 문제, 원인은 바로 리액트의 렌더링 방식 때문이다.

새로운 상태를 사용자의 UI에 보여주기 위해선 반드시 리렌더링이 필요하다.

리렌더링은 함수컴포넌트의 재실행, useState의 두번째 인수 호출등 다양한 방식으로 일어난다.

즉, 업데이트되는 값을 가져오려면 해당 상태를 업데이트하는 것뿐만 아니라 상태가 업데이트됐을 때, 컴포넌트에 반영시키기 위한 리렌더링이 필요하다.

<aside>
⛔ **함수 외부에서 상태를 참조하고, 이를 통해 렌더링까지 자연스럽게 일어나기 위한 조건**
1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 사용할 수 있어야 한다.

2. 외부의 상태를 사용하는 컴포넌트는 상태 변화를 알아챌 수 있어야 하고, 상태 변화가 일어나면 리렌더링이 일어나 최신 상태값을 기준으로 렌더링 되어야 한다.
   이 상태 감지는 상태를 변화시키는 컴포넌트 뿐만 아니라 상태를 참조하는 모든 컴포넌트에서 동일하게 작용해야 한다.

3. 상태가 원시값이 아닌 객체인 경우에 그 객체 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해선 안된다.
   ex : {a: 1, b: 2}인 객체가 있을 때, a=2로 업데이트 된다면
   객체 값의 변화가 단순히 b의 값을 참조하는 컴포넌트에선 리렌더링을 일으켜서는 안된다.

</aside>

- 리액트 외부에서 관리되는 값에 대한 변경을 추적하고, 이를 리렌더링할 수있는 훅
- ex . 페이스북 팀에서 만든 useSubscription
