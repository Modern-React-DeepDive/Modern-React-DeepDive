# [5.2] 리액트 훅으로 시작하는 상태 관리

## [5.2.1] useState와 useReducer : 지역 상태 관리

- useCounter훅을 만들어서 함수 컴포넌트 어디서든 사용 가능하게 구현한 사례

```jsx
function useCounter(initCount = 0) {
  const [counter, setCounter] = useState(initCount)

  function inc() {
    setCounter((prev) => prev + 1)
  }
  /*외부에서 받은 숫자나 0을 초깃값으로 상태를 관리하며, 
 inc를 선언해 숫자를 1씩 증가할 수 있도록 구현했다.*/

  return { counter, inc }
}
```

⇒ useCounter를 사용하는 함수 컴포넌트는 이 훅을 사용해 각자의 counter변수를 관리하며

중복되는 로직 없이 숫자 1을 증가시킬 수 있다.

이처럼, 리액트 훅을 기반으로 만든 사용자 정의 훅은 함수 컴포넌트 어디서든 쉽게 재사용 가능하다.

- useReducer또한 지역 상태를 관리할 수 있는 훅이다.

\*useState는 useReducer로 구현됨

useState와 useReducer가 모든 상태 관리의 필요를 해결해줄까? ⇒ no !

❗useState와 useReducer 기반의 사용자 지정 훅의 한계는 명확하다.

: 훅을 사용할 때 마다 컴포넌트별로 초기화되어 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.

(컴포넌트 상태의 파편화)

이렇게 기본적인 useState를 기반으로 한 상태를 지역 상태라고 하며,

이 지역 상태는 해당 컴포넌트에서만 유효하다는 한계가 있다.

❓지역 상태 ⇒ 전역 상태로 만들어 컴포넌트가사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면?

## [5.2.2] 지역 상태 한계 벗어나기 : useState상태 바깥으로 분리하기

- **useState의 한계**
  useState는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되어
  해당 컴포넌트만 사용 가능하다는 단점이 있다.

만약, 어디에선가 해당 값을 업데이트하면 그 값을 참조하고 있는 컴포넌트나 훅에서도 업데이트 된 값을 사용할 수 있지 않을까?

⇒ 리액트에선 작동하지 않는다.

컴포넌트가 리렌더링 되지 않는 문제, 원인은 바로 리액트의 렌더링 방식 때문이다.

새로운 상태를 사용자의 UI에 보여주기 위해선 반드시 리렌더링이 필요하다.

리렌더링은 함수컴포넌트의 재실행, useState의 두번째 인수 호출등 다양한 방식으로 일어난다.

즉, 업데이트되는 값을 가져오려면 해당 상태를 업데이트하는 것뿐만 아니라 상태가 업데이트됐을 때, 컴포넌트에 반영시키기 위한 리렌더링이 필요하다.

<aside>
⛔ **함수 외부에서 상태를 참조하고, 이를 통해 렌더링까지 자연스럽게 일어나기 위한 조건**
1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 사용할 수 있어야 한다.

2. 외부의 상태를 사용하는 컴포넌트는 상태 변화를 알아챌 수 있어야 하고, 상태 변화가 일어나면 리렌더링이 일어나 최신 상태값을 기준으로 렌더링 되어야 한다.
   이 상태 감지는 상태를 변화시키는 컴포넌트 뿐만 아니라 상태를 참조하는 모든 컴포넌트에서 동일하게 작용해야 한다.

3. 상태가 원시값이 아닌 객체인 경우에 그 객체 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해선 안된다.
   ex : {a: 1, b: 2}인 객체가 있을 때, a=2로 업데이트 된다면
   객체 값의 변화가 단순히 b의 값을 참조하는 컴포넌트에선 리렌더링을 일으켜서는 안된다.

</aside>

- 리액트 외부에서 관리되는 값에 대한 변경을 추적하고, 이를 리렌더링할 수있는 훅
- ex . 페이스북 팀에서 만든 useSubscription

## [5.2.3] useState와 Context동시에 사용

현재 리액트 생태계에는 많은 상태 관리 라이브러리가 있지만 이것들이 작동하는 방식은 다음과 같이 요약할 수 있다.

→ useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다.

이는 컴포넌트의 최상단 내지는 상태가 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.

→ 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

## [5.2.4] 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기.

리덕스와 MobX의 대안으로 각광받고 있는 라이브러리이다.

### Recoil, Jotai

- Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞추고 있다.

### Zustand

- 리덕스와 비슷하게 하나의 큰 스토어(실제 상태에 따른 값과 상태 변경 메소드)를 기반으로 하는 라이브러리이다.

이 하나의 큰 스토어는 Recoil, Jotai와 달리 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 렌더링을 알린다.

⇒ 세 상태 관리 라이브러리가 지향하는 목적

⇒ 라이브러리 내부에서 어떻게 상태 관리?

⇒ 이 상태를 어떻게 전파해 렌더링을 일으키는지..

---

### Recoil

- Recoil은 페이스북이 만들었다.
- 최소 상태 개념인 Atom(상태값 저장 스토어)을 처음 선보였다.
- 리액트 18에서 제공되는 동시서으 렌더링, 서버 컴포넌트, SSR등이 지원되기 전까지 1.0.0 을 릴리스 하지 않을 것이라 밝힌 바 있다.
- 아직 까지 안전성 보장이 힘들다.

**RecoilRoot**

Recoil 사용을 위해 최상단에 선언해야 한다.

RecoilRoot에선 Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성한다.

<aside>
👨‍🚒 **RecoilRoot의 구조**

- Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
- 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
- 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.
</aside>

- **atom**

  Recoil의 최소 상태 단위이다.

  키 값을 필수로 가지며, 이 키는 다른 atom과 구별하는 식별자가 되는 필수 값이다.

  이 키는 어플리케이션 내부에서 유일한 값이어야 하기 때문에 주의를 기울여야 한다.

- **useRecoilValue**
  useRecoilValue는 atom의 값을 읽어오는 훅이다.
- **useRecoilState**
  useState와 유사하게 값을 가져오고, 이 값을 변경할 수도 있다.
- 특징
  selector를 필두로 다양한 비동기 작업을 지원하는 API를 제공한다.
  리덕스와 달리 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 할 수 있다.
  자체적인 개발 도구를 지원해 Recoil을 기반으로 개발하는데 더 도움이 된다.

### Jotai

- Recoil에서 영감을 받아 만들어진 상태 관리 라이브러리이다.
- buttom-up 접근법을 취하고 있다.
- 리덕스와 같이 하나의 큰 상태를 어플리케이션에 내려주는 방식이 아닌,
  작은 단위의 상태를 위로 전파하는 구조를 갖고 있다.
- 리액트 Context의 문제점인 불필요한 렌더링이 일어난다는 문제를 해결하고자 설계되었다.

- **atom**
  recoil의 atom과 마찬가지로 최소의 상태를 의미한다.
  _하지만 Recoil과 다르게 atom하나만으로 상태를 만들 수도, 이에 파생된 상태를 만들 수도 있다.
  또한 atom 생성 시 마다 고유한 key를 필요했던 recoil과 다르게 key값을 별도로 넘겨주지 않아도 된다.._

⇒ Jotai의 atom은 별도로 상태를 저장하고 있지 않다.

그렇다면 어디에 저장해 두는 걸까?

: useAtomValue

- useAtom
  useState와 동일한 형태의 배열을 반환한다. 첫 번째로는 atom의 현재값을 나타내는 useAtomValue훅의 결과를 나타내며 두 번째는 useAtomState훅을 반환한다.

- 특징
  라이브러리의 태생 자체가 Recoil에서 많은 영감을 받은 만큼 Recoil과 유사한 면이 많다.
  Recoil의 단점을 극복하기 위한 노력이 보이는데,

1. atom개념을 도입하며 API가 간결하다는 점을 꼽을 수 있다.
2. Recoil에서는 atom에서 파생된 값을 만들기 위해서 selector가 필요했지만 Jotai에서는 selector3. 없이도 atom만으로 또 다른 파생된 상태를 만들 수 있다. ⇒ recoil에 비해 간결하다.
3. 타입스크립트로 작성되어 있어 타입을 잘 지원한다.
4. Jotai또한 리액트 18의 변경된 API를 원활하게 지원한다.

### Zustand

- 작고 빠르며 확장에 유연하다.
- 리덕스에 영감을 받아 만들어졌다.
- atom이 아닌 하나의 스토어를 중심으로 중앙 집중형으로 활용된다.

- 특징
  특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다.
  타입스크립트로 작성되어 있어 자연스럽게 사용 가능하다.
  미들웨어를 지원한다. : 상태를 추가로 저장하는 등 기본적인 관리 작동 외 추가적인 작업을 정의할 수 있다.
