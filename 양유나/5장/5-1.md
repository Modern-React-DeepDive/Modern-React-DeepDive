# [5장] 리액트와 상태관리

# [5.1] 상태 관리는 왜 필요할까?

**상태**

어떠한 의미를 지닌 값이며, 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값이다.

**웹 어플리케이션에서 상태로 분류될 수 있는 것들**

- UI : 상호작용 가능한 모든 값
- URL : 주소는 사용자의 라우팅에 따라 변경된다.
- form : loading, submit, disable, validation인지 등등
- 서버에서 가져온 값 : 클라이언트 → 서버 요청을 통해 가져온 값 (ex. API 요청)

**상태관리에서 고민해야 할 것들**

상태를 어디에 둘 것인가? ⇒ 전역변수?, 별도의 클로저?

그 상태가 유효한 범위는 어떻게 제한할까?

상태에 따라 변경되어야 하는 자식 요소들은 어떻게 변화를 감지할 것인지?

요소들이 변경되며 어플리케이션이 찢어지는 현상 (tearing)을 어떻게 방지할 것인지 등등

## [5.1.1] 리액트 상태 관리의 역사

### **Flux 패턴 등장**

당시, 어플리케이션이 비대해지고 데이터도 많아져서 어디서 어떤 일이 일어나서 상태가 변했는지 추적하기 어려운 상황이었다.

페이스북 팀은 이 문제의 원인을

“양방향 데이터 바인딩”으로 보고 “단방향 데이터”로 흐름을 변경하는 것을 제안했다.

- 기존 MVC 패턴 : view(html) ↔ model(js)

png1

- Flux 패턴의 단방향 흐름

png2
action : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함 시킬 데이터를 정의한다.

즉, **액션 타입**과 **데이터**를 정의해 디스패처로 보낸다.

dispatcher : **액션**을 **스토어**에 보낸다.

콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터 모두 스토어에 보낸다.

sotre : 실제 상태에 따른 값과 **상태를 변경할 수 있는 메서드**를 갖고 있다.

**액션의 타입에 따라 이를 어떻게 변경할지** 정의되어 있다.

view : 리액트의 컴포넌트에 해당하는 부분이다.

스토어에서 만들어진 데이터를 가져와 화면을 **렌더링**한다.

뷰에서 사용자의 입력이나 행위에 따라 상태를 업데이트하려면 아래의 그림처럼 view에서 action을 호출하는 구조로 구성된다.

png3
⇒ 단점 : 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트 해야하는지 코드로 작성해야 하므로 코드의 양이 많아지고 수고로워진다.

그러나 데이터의 흐름을 추적하기 쉽고 코드를 이해하기 수월해진다.

### 리덕스(Redux) 등장

- Flux구조를 구현하기 위해 만들어진 라이브러리
- 특별한 건 : Elm 아키텍처 도입

EIm(Enterprise Identity Mapping) : 웹 페이지를 선언적으로 작성하기 위한 언어이다.

⇒ EIm은 Flux와 마찬가지로 데이터 흐름을 세가지로 분류하며, 단방향으로 강제헤 어플리케이션 상태를 안정적으로 관리하고자 했다.

💡**EIm 핵심**

- 모델 : 어플리케이션의 상태를 의미한다.
- 뷰 : 모델을 표현하는 HTML을 의미한다.
- 업데이트 : 모델을 수정하는 방식이다.

🌳 **리덕스의 등장은 리액트 생태계에 많은 영향을 끼쳤다.**

하나의 글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있었다.

⇒ props를 깊이 전파해야 하는 prop내려주기 문제를 해결

스토어가 필요한 컴포넌트라면

⇒ connect 사용

😢 **리덕스 단점**

하나의 상태 변경하려면? ⇒ 할 일이 너무 많다.

어떤 액션 타입인지 정의해야 하고,

액션을 수행할 creator함수를 만들어야 하고,

dispatcher와 selector도 필요하고,

새로운 상태가 기존의 리듀서 내부에서 어떤 식으로 변경돼야 할지,

새로 만들어야 할지

즉, 하고자 하는 일에 비해 **보일러플레이트**가 너무 많다. (지금은 작업이 많이 간소화 되었다.)

### context API 와 useContext

리액트가 처음 나왔을 때, 어떻게 상태를 주입해야 하는지에 대한 고민은 계속 이어졌다.

prop내려주기 불편함이 있었다. (리덕스의 보일러플레이트도 부담)

리액트 팀은 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API 를 출시했다.

⇒ 를 사용하면 props로 상태를 넘겨주지 않아도 원하는 곳에서 context Provider가 주입하는 상태를 이용할 수 있게 되었다.

Context API 출시 전에도 context가 존재했으며 context를 다루기 위한 getChildContext()를 제공했다.

⇒ 문제점

- 상위 컴포넌트가 렌더링 되면 getChildContext가 호출됨과 동시에 shouldComponentUpdate가 항상 true를 반환해 불필요한 렌더링이 일어난다.
- getChildcontext를 사용하려면 context를 인수로 받아야 하는데 이러면 결합도가 높아진다.

ContextAPI는 이러한 문제점을 보완하여 출시되었다.

부모 컴포넌트에 상태를 선언하고, 이를 Context로 주입한다.

ContextAPI는 상태관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능이 존재하지 않으니 사용 시 주의가 필요하다.

### 훅의 탄생, 그리고React Query와 SWR

Context API가 출시된 지 1년이 되지 않아 리액트 16.8에선 함수 컴포넌트에서

사용 가능한 다양한 훅 API를 추가했다.

⇒ state를 쉽게 재사용 가능하도록 만든 것이 가능 큰 변경점이다,

```jsx
import React, { useState } from 'react'

function useCounter() {
  const [count, setCount] = useState(0)

  function increase() {
    setCount((prev) => prev + 1)
  }

  return { count, increase }
}
```

⇒ 이러한 훅과 state등장으로 새로운 방식의 상태관리가 등장했다.

- ReactQuery
- SWR : useSWR의 첫 번째 인수는 조회할 API, 두 번째 인수는 조회에 사용되는 fetch를 넘겨준다.

두 라이브러리는 외부에서 데이터를 불러오는 fetch를 관리하는데 특화된 라이브러리 이지만,

API호출에 대한 상태를 관리하고 있기 때문에 HTTP요청에 특화된 상태 관리 라이브러리라고 볼 수 있다.

### Recoil, Zustand, Jotai, Valtio

ReactQuery와 SWR에 비해 좀 더 범용적으로 사용 가능한 상태 관리 라이브러리이다.

⇒ 위 라이브러리는 리액트와 연동을 전제로 작동해 별도 라이브러리를 설치하지 않아도 된다.

이는 원하는 만큼의 상태를 지역적 관리가 가능하고,
훅을 지원하여 함수 컴포넌트에서 손쉬운 사용이 가능하다.
