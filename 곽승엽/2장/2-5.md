# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

<br>

## 1. 메모이제이션

컴퓨터가 동일한 계산을 반복하지 않도록 결과를 **저장**하여 성능을 최적화하는 방법

⇒ 결과를 **저장**한 뒤, 동일한 입력으로 호출이 오면 **저장된 결과를 반환**하여 **불필요한 계산을 예방**하는 것

리액트에서는 이를 활용할 수 있도록 `useMemo`, `useCallback` 훅과 고차 컴포넌트인 `memo`를 제공

<br>

### 1) useMemo

---

**계산의 결과**를 메모이제이션하는데 사용하는 훅

의존성 배열에 있는 값들이 변경되지 않는 한 **이전에 계산된 값을 반환**

**용도**: 연산이 많은 계산의 결과에 적용

**효과**: 불필요한 연산 방지 

```jsx
import React, { useMemo } from 'react';

const Component = () => {
  const [count, setCount] = useState(0);
 
	// useMemo를 통해 결과 값 메모이제이션
  // count값이 변경되지 않은 경우: 이전에 계산된 값을 반환
  // count값이 변경된 경우: 계산하여 값을 반환
  const computedValue = useMemo(() => {
    return count * 2;
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

<br>

### 2) useCallback

---

**함수**를 메모이제이션하는데 사용하는 훅

의존성 배열에 있는 값들이 변경되지 않는 한 **동일한 함수 인스턴스를 반환**

**용도**: 자식 컴포넌트에 콜백 함수를 전달할 때 사용

**효과**: 불필요한 함수 재생성 방지 

```jsx
import React, { useMemo, useCallback } from 'react';

const ParentComponent = () => {
  // useCallback을 통해 함수 메모이제이션
  const handleButtonClick = useCallback(() => {
    console.log('Button clicked');
  }, []);

  return (
    <div>
      <button onClick={handleButtonClick}>Click</button>
    </div>
  );
};
```

<br>

### 3) memo

---

**컴포넌트 자체**를 메모이제이션하는 고차 컴포넌트(HOC)

props가 변경되지 않는 한 **컴포넌트를 다시 렌더링하지 않음**

**용도:** props가 변경되지 않을 때 불필요한 재렌더링을 방지

**효과:** 불필요한 재렌더링 예방

```jsx
import React, { useState } from 'react';

// React.memo를 사용하여 컴포넌트를 메모이제이션
// props인 count값이 변경되지 않는 한 재랜더링하지 않음
const ChildComponent = React.memo(({ count }) => {
  console.log('ChildComponent rendered');
  return <div>Count: {count}</div>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ChildComponent count={count} />
    </div>
  );
};

export default ParentComponent;

```

<br>

## 2. 메모이제이션, 언제 하는 것이 좋은가?

효율적으로 메모이제이션을 하는 방법은 무엇일까?

필요한 곳에만 추가하는게 좋을지, 모든 곳에 메모이제이션을 추가하는 것이 좋을지

<br>

### 1) 꼭 필요한 곳에만 메모이제이션을 추가한다

---

**주장**

메모이제이션은 만능이 아니다

<br>

**이유**

메모이제이션도 비용이 든다 

- 값을 비교하고 렌더링 또는 계산이 필요한지 확인하는 비용
- 메모리에 결과물을 저장해 두고 다시 꺼내오는 비용

메모이제이션을 모두 적용하면 메모리 사용량이 불필요하게 증가한다

- 메모리 공간이 부족할 경우 저장(캐싱)한 결과물이 사라져 메모이제이션의 기능을 활용하지 못할 수 있다

<br>

**결론**

성능 최적화를 위해 메모이제이션을 사용하지만 **메모이제이션도 비용이 들고**, **불필요한 메모리 사용량이 증가**할 수 있다. (모든 곳에 메모이제이션을 활용하는 것이 옳았다면, 리액트 개발 팀에서는 애초에 컴포넌트 생성자에 memo를 감싸두었을 것이다.) 따라서 모든 곳에 적용하기 보다는 **렌더링 비용과 메모이제이션의 비용을 비교**하여꼭 필요한 부분에만 적용해야 한다.

<br>

### 2) 모든 곳에 메모이제이션을 추가한다

---

**주장**

꼭 필요한 곳에 적용하는게 이상적인 것은 알고있지만, 규모가 커질수록 성능 최적화에 신경쓰기 어렵다

따라서 일단 모든 곳에 메모이제이션을 추가하고 생각하는 것이 좋다

<br>

**이유**

잘못된 memo로 지불해야 하는 비용이 크지 않을 수 있다

- 메모이제이션은 결과물들을 비교하고, 리렌더링할 필요가 없다면 이전 결과물을 사용하는 비용이 든다
- 하지만 리액트는 기본적으로 **재조정 알고리즘**이 들어가 있어서 어차피 이전 결과물들을 저장하고 있다
- 즉, 잘못된 memo로 지불해야 하는 비용은 **props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용뿐이다**

memo를 하지 않았을 때 발생할 수 있는 문제가 더 크다

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어난다

> 재조정 알고리즘: Virtual DOM의 이전 상태(구 트리)와 현재 상태(신규 트리)를 비교하여 변경 사항을 감지하고, 변경된 부분만 실제 DOM에 반영함으로써 효율적인 업데이트를 수행하는 것
> 

<br>

### 3) 결론

---

메모이제이션은 결과물을 저장하여 불필요한 계산, 호출, 렌더링을 방지할 수 있다. 

하지만 메모이제이션은 만능이 아니다. 

메모이제이션도 비용이 존재하고, 불필요한 메모이제이션으로 인한 비용을 무시할 수 없다. 

따라서 섣부른 메모이제이션을 지양하고, 성능상 이점을 판단하여 적용하는 것이 좋다.

(시간이 부족한 상황이라면 일단 적용을 해두는 것이 나쁘지 않다는 의견도 있긴하다.)

<br>

이상적인 메모이제이션 적용 방법은 다음과 같다

- 프로파일링 도구를 사용하여 성능 병복 지점을 식별하고, 해당 부분에만 메모이제이션을 적용
- 연산이 많은 계산이나 반복적으로 호출되는 함수에만 메모이제이션을 적용