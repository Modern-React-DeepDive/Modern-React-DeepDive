# 리액트의 렌더링

<br>

## 1. 리액트 렌더링이란?

`HTML`과 `CSS` 리소스를 기반으로 웹페이지에 필요한 `UI를 그리는 과정`

→ 브라우저가 렌더링에 필요한 `DOM 트리를 만드는 과정`

<br>

리액트에서의 `렌더링`을 풀어서 설명하면 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 `props와 state의 값을 기반으로` 어떻게 `UI를 구성`하고, 이를 바탕으로 어떤 `DOM 결과`를 `브라우저에 제공`할 것인지 계산하는 일련의 과정을 뜻한다.

<br>

## 2. 리엑트 렌더링이 발생하는 경우

<br>

### 1) 최초 렌더링

---

사용자가 `처음` 애플리케이션에 진입했을 때 정보를 제공하기 위해

<br>

### 2) 리렌더링

---

`최초 렌더링`이 발생한 이후에 모든 렌더링을 의미

<br>

**발생하는 경우**

- `클래스 컴포넌트`의 `setState`가 실행되는 경우
    - state의 변화 → 컴포넌트 상태의 변화를 뜻함
    - 클래스 컴포넌트는 setState를 통해 상태를 업데이트 하므로 리렌더링 발생
- `클래스 컴포넌트`의 `forceUpdate`가 실행되는 경우
    - 클래스 컴포넌트는 render 메서드를 통해 렌더링 수행
    - render가 state와 props가 아닌 다른 값에 의존하고 있을 경우 자동으로 렌더링이 발생하지 않음
    - forceUpdate 를 통해 강제로 렌더링 가능
- `함수 컴포넌트`의 `useState()`의 두 번째 배열 요소인 `setter`가 실행된 경우
    - 클래스 컴포넌트의 setState와 마찬가지로 state를 업데이트하는 함수
- `함수 컴포넌트`의 `useReducer()`의 두 번째 배열 요소인 `dispatch`가 실행되는 경우
    - useState와 마찬가지로 state를 업데이트하는 dispatch 함수 존재
- `컴포넌트`의 `key props`가 변경되는 경우
    - key란 명시적으로 선언하지 않아도 모든 컴포넌트에서 사용할 수 있는 특수한 props임
    - 리렌더링에 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값으로 사용
    - current 트리와 workInProgress 트리 사이에서 같은 컴포넌트를 식별하기 위해 사용
- `props`가 변경되는 경우
    - 부모로부터 전달받는 값인 props가 달라지면 자식 컴포넌트에서도 변경이 필요하기 때문에
- `부모 컴포넌트`가 렌더링될 경우
    - 부모 컴포넌트가 리렌더링되면, 자식 컴포넌트도 무조건 리렌더링이 발생함
    - 이를 막기 위한 과정 → 메모이제이션

<br>

## 3. 리액트의 렌더링 프로세스

<br>

### **1) 결과물 수집 과정**

---

1. 리액트가 컴포넌트의 `루트`에서부터 내려가면서 `업데이트`가 필요하다고 지정되어 있는 모든 컴포넌트 색출
2. 업데이트가 필요한 모든 컴포넌트에서 렌더링 실행
    1. 클래스 컴포넌트 : `render()` 함수 실행
    2. 함수 컴포넌트 : `FuctionComponent()` 그 자체를 호출한 뒤, 그 결과물을 저장
3. 일반적으로 `JSX` 문법으로 구성된 결과물을 받음
4. 결과물은 자바스크립트로 `컴파일`되며 `React.creatElement()`를 호출하는 구문으로 변환
5. `createElement()`로 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 `객체`로 변환

<br>

**예시 코드**

```jsx
// JSX 문법으로 구성된 컴포넌트
function Hello(){
	return(
		<TestComponent a={35} b="yceffor">
			안녕하세요.
		</TestCompoent>
	)
}
```

```jsx
// React.createElement를 호출하여 변환됨
function Hello(){
	return React.createComponent(
		TestComponent,
		{ a=35, b='yceffor'},
		'안녕하세요',
	)
}
```

```jsx
// 최종 결과물
{type: TestComponent, props: {a:35, b:"yceffor", children:"안녕하세요"}
```

<br>

### **2) 결과물 수집 이후**

---

1. 위와 같은 과정을 거쳐 각 컴포넌트의 렌더링 `결과물`을 수집
2. 리액트의 새로운 트리인 `가상 DOM`과 비교해 `실제 DOM`에 반영하기 위한 모든 `변경 사항`을 차례차례 수집함

이러한 계산과정을 `리액트의 재조정(Reconcilation)`이라고 한다.

재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀸스로 DOM에 적용해 변경된 결과물이 보이게 된다.

여기서 주목할 점은 **리액트의 렌더링**을 `렌더 단계`, `커밋 단계` 총 두 단계로 분리되어 실행된다.

<br>

## 4. 렌더와 커밋

<br>

### 1) 렌더 단계

---

컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업

렌더링 프로세스에서 얻은 `결과물`과 `이전 가상 DOM`을 `비교`해, `변경이 필요한 컴포넌트를 체크`하는 단계

여기서 비교하는 것은 크게 `type`, `props`, `key` 이다. (셋 중 하나라도 변경되었을 경우 체크)

<br>

### 2) 커밋 단계

---

렌더 단계의 `변경 사항`을 `실제 DOM`에 `적용해` 사용자에게 보여주는 과정 (변경 사항이 없다면 패스)

리액트가 DOM을 커밋 단계에서 업데이트한다면, 리액트 내부의 참조를 업데이트 함

- 클래스 컴포넌트 : `componentDidMount`, `componentDidUpdate` 호출
- 함수 컴포넌트 : `useLayoutEffect` 훅 호출

<br>

**참고 자료**
[React Lifecycle Methods diagram](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)